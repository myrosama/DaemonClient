    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>DaemonClient</title>
        <!-- Tailwind CSS for styling -->
        <script src="https://cdn.tailwindcss.com"></script>
        <!-- React and Babel for running React in the browser -->
        <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
        <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
        <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

        <!-- Firebase SDKs -->
        <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
        <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
        <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
        <!-- Firebase Functions SDK -->
        <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-functions.js"></script>

    </head>
    <body class="bg-gray-900">
        <div id="root"></div>

        <script type="text/babel">
        // --- Firebase Initialization ---
        const firebaseConfig = {
            apiKey: "AIzaSyBH5diC5M7MnOIuOWaNPmOB1AV6uJVZyS8",
            authDomain: "daemonclient-c0625.firebaseapp.com",
            databaseURL: "https://daemonclient-c0625-default-rtdb.firebaseio.com",
            projectId: "daemonclient-c0625",
            storageBucket: "daemonclient-c0625.firebasestorage.app",
            messagingSenderId: "424457448611",
            appId: "1:424457448611:web:bea9f7673fb40f137de316",
            measurementId: "G-72V5NJ7F2C"
        };

        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        const appIdentifier = 'default-daemon-client'; 

        // ============================================================================
        // --- HELPER FUNCTIONS & SHARED COMPONENTS (UNCHANGED) ---
        // ============================================================================
        const CHUNK_SIZE = 19 * 1024 * 1024;
        const UPLOAD_RETRIES = 10;
        const DOWNLOAD_RETRIES = 5;
        const PROACTIVE_DELAY_MS = 1000;
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
        function formatSpeed(bytes) { if (!bytes || bytes < 1024 || isNaN(bytes)) return `...`; if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(2)} KB/s`; return `${(bytes / (1024 * 1024)).toFixed(2)} MB/s`; }
        function formatETA(seconds) { if (seconds === Infinity || isNaN(seconds) || seconds < 1) return '...'; const h = Math.floor(seconds / 3600); const m = Math.floor((seconds % 3600) / 60); const s = Math.floor(seconds % 60); return [h > 0 ? `${h}h` : '', m > 0 ? `${m}m` : '', s > 0 ? `${s}s` : (h===0 && m===0 ? '0s' : '')].filter(Boolean).join(' ') || '...'; }
        
        async function uploadFile(file, botToken, channelId, onProgress, abortSignal) {
            // --- OPTIMIZATION: We will upload multiple chunks at the same time ---
            const CONCURRENT_UPLOADS = 4; // Number of parallel uploads. 4 is a safe and effective number.

            const totalParts = Math.ceil(file.size / CHUNK_SIZE);
            const uploadedMessageInfo = new Array(totalParts); // Pre-size the array to store results in order
            let uploadedBytes = 0;
            const startTime = Date.now();
            const queue = [...Array(totalParts).keys()]; // A queue of part indexes to upload: [0, 1, 2, ...]

            const uploadPart = async (partIndex) => {
                const chunk = file.slice(partIndex * CHUNK_SIZE, (partIndex + 1) * CHUNK_SIZE);
                for (let attempt = 1; attempt <= UPLOAD_RETRIES; attempt++) {
                    if (abortSignal.aborted) throw new Error("Upload was cancelled by the user.");
                    try {
                        const formData = new FormData();
                        formData.append('chat_id', channelId);
                        formData.append('document', chunk, `${file.name}.part${String(partIndex + 1).padStart(3, '0')}`);
                        
                        const response = await fetch(`https://api.telegram.org/bot${botToken}/sendDocument`, { method: 'POST', body: formData, signal: abortSignal });
                        const result = await response.json();

                        if (result.ok) {
                            // This is thread-safe in JS. Update global progress.
                            uploadedBytes += chunk.size;
                            const elapsedTime = (Date.now() - startTime) / 1000 || 1;
                            const speed = uploadedBytes / elapsedTime;
                            const remainingBytes = file.size - uploadedBytes;
                            const eta = (speed > 0 && remainingBytes > 0) ? remainingBytes / speed : Infinity;
                            onProgress({ percent: Math.round((uploadedBytes / file.size) * 100), status: `Uploading... (${Math.round((uploadedBytes / file.size) * 100)}%)`, speed: formatSpeed(speed), eta: formatETA(eta) });

                            // Store result in the correct array index to maintain order
                            uploadedMessageInfo[partIndex] = { message_id: result.result.message_id, file_id: result.result.document.file_id };
                            return; // Success, exit the retry loop
                        } else {
                            if (response.status === 429 && result.parameters?.retry_after) {
                                const retryAfter = parseInt(result.parameters.retry_after, 10);
                                onProgress(prev => ({ ...prev, status: `Rate limited. Waiting ${retryAfter}s...` }));
                                await sleep(retryAfter * 1000 + 500);
                            } else {
                                await sleep(2000 * attempt);
                            }
                        }
                    } catch (error) {
                        if (error.name === 'AbortError') throw error;
                        if (attempt >= UPLOAD_RETRIES) throw new Error(`Part ${partIndex + 1} failed after ${UPLOAD_RETRIES} attempts: ${error.message}`);
                        await sleep(3000 * attempt);
                    }
                }
                throw new Error(`Upload failed for part ${partIndex + 1}. All retries exhausted.`);
            };

            const worker = async () => {
                while (queue.length > 0) {
                    const partIndex = queue.shift();
                    if (partIndex !== undefined) {
                        await uploadPart(partIndex);
                    }
                }
            };
            
            const workers = Array(CONCURRENT_UPLOADS).fill(0).map(() => worker());
            await Promise.all(workers);

            onProgress({ percent: 100, status: `Upload complete!`, speed: '', eta: ''});
            return uploadedMessageInfo;
        }

        async function downloadFile(fileInfo, botToken, onProgress, abortSignal) {
            const { messages, fileName, fileSize, fileType } = fileInfo;
            const totalParts = messages.length;
            const partBlobs = new Array(totalParts);
            let downloadedBytes = 0;
            let completedParts = 0;
            const startTime = Date.now();
            const CONCURRENT_DOWNLOADS = 5;
            async function downloadPartWithRetry(partData, index) {
                for (let attempt = 1; attempt <= DOWNLOAD_RETRIES; attempt++) {
                    if (abortSignal.aborted) throw new Error("Download was cancelled by the user.");
                    try {
                        const fileInfoUrl = `https://api.telegram.org/bot${botToken}/getFile?file_id=${partData.file_id}`;
                        const fileInfoRes = await fetch(fileInfoUrl, { signal: abortSignal });
                        const fileInfoData = await fileInfoRes.json();
                        if (!fileInfoData.ok) throw new Error(`TG getFile error: ${fileInfoData.description || "Unknown"}`);
                        const filePath = fileInfoData.result.file_path;
                        const proxyUrl = new URL('https://us-central1-daemonclient-c0625.cloudfunctions.net/telegramDownloadProxy');
                        proxyUrl.searchParams.append('botToken', botToken);
                        proxyUrl.searchParams.append('filePath', filePath);
                        const fileRes = await fetch(proxyUrl.toString(), { signal: abortSignal });
                        if (!fileRes.ok) throw new Error(`Proxy error ${fileRes.status}: ${await fileRes.text()}`);
                        return await fileRes.blob();
                    } catch (error) {
                        if (error.name === 'AbortError') throw error;
                        if (attempt >= DOWNLOAD_RETRIES) throw error;
                        await sleep(2000 * attempt);
                    }
                }
            }
            return new Promise((resolve, reject) => {
                const queue = [...messages.entries()]; 
                const runNext = () => {
                    if (abortSignal.aborted) return reject(new Error("Download was cancelled."));
                    if (completedParts === totalParts) {
                        onProgress({ percent: 100, status: `Assembling file...`, speed: '', eta: '' });
                        const fullBlob = new Blob(partBlobs, { type: fileType || 'application/octet-stream' });
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(fullBlob);
                        link.download = fileName;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(link.href);
                        resolve();
                        return;
                    }
                    if(queue.length > 0) {
                        const [index, partData] = queue.shift();
                        downloadPartWithRetry(partData, index).then(blob => {
                            partBlobs[index] = blob;
                            downloadedBytes += blob.size;
                            completedParts++;
                            const elapsedTime = (Date.now() - startTime) / 1000 || 1;
                            const speed = downloadedBytes / elapsedTime;
                            const remainingBytes = fileSize - downloadedBytes;
                            const eta = (remainingBytes > 0 && speed > 0) ? remainingBytes / speed : 0;
                            onProgress({ percent: Math.round((downloadedBytes / fileSize) * 100), status: `Downloaded part ${completedParts}/${totalParts}...`, speed: formatSpeed(speed), eta: formatETA(eta) });
                            runNext();
                        }).catch(reject);
                    }
                };
                for (let i = 0; i < CONCURRENT_DOWNLOADS && i < totalParts; i++) runNext();
            });
        }

        async function deleteTelegramMessages(botToken, channelId, messages) {
            for (const message of messages) {
                try {
                    await fetch(`https://api.telegram.org/bot${botToken}/deleteMessage`, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ chat_id: channelId, message_id: message.message_id })
                    });
                } catch (error) { console.error(`Network error deleting message ${message.message_id}:`, error); }
                await sleep(350);
            }
        }
        
        const LoaderComponent = ({ small }) => <div className={`animate-spin rounded-full border-b-2 border-white ${small ? 'h-6 w-6' : 'h-10 w-10'}`}></div>;
        const LockIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="mr-2 h-10 w-10 text-indigo-400"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>;
        const FullScreenLoader = ({message}) => <div className="flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white"><LoaderComponent /><p className="mt-4 text-lg">{message || "Loading Application..."}</p></div>;
        const RenameIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>;
        
        const ProgressBar = ({ percent, status, speed, eta, onCancel }) => (
            <div className="w-full mt-4">
                <div className="flex justify-between items-center mb-1 text-xs text-gray-300">
                    <span>{status}</span>
                    <div className="flex items-center">
                        <span className="mr-4">{eta || '...'}</span>
                        {onCancel && <button onClick={onCancel} className="text-red-400 hover:text-red-300 text-xs font-bold">CANCEL</button>}
                    </div>
                </div>
                <div className="w-full bg-gray-600 rounded-full h-2.5"><div className="bg-indigo-500 h-2.5 rounded-full" style={{ width: `${percent}%` }}></div></div>
                <div className="text-center text-sm font-semibold text-indigo-300 mt-1">{speed || '...'}</div>
            </div>
        );
        
        const SettingsModal = ({ initialConfig, onSave, onClose, isSaving }) => {
            const [botToken, setBotToken] = React.useState(initialConfig.botToken || '');
            const [channelId, setChannelId] = React.useState(initialConfig.channelId || '');
            const [error, setError] = React.useState('');
            const handleSave = async () => {
                if (!botToken.trim() || !channelId.trim()) { setError("Bot Token and Channel ID cannot be empty."); return; }
                setError('');
                try { await onSave({ botToken, channelId }); } catch (err) { setError(`Save failed: ${err.message}`); }
            };
            return (
                <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 font-sans">
                    <div className="bg-gray-800 rounded-xl shadow-2xl p-8 w-full max-w-lg">
                        <h2 className="text-2xl font-bold text-indigo-400 mb-4">Settings</h2>
                        <div className="space-y-4">
                            <div>
                                <label htmlFor="botToken-settings" className="block text-sm font-medium text-gray-300 mb-1">Telegram Bot Token</label>
                                <input id="botToken-settings" type="password" value={botToken} onChange={(e) => setBotToken(e.target.value)} className="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white" />
                            </div>
                            <div>
                                <label htmlFor="channelId-settings" className="block text-sm font-medium text-gray-300 mb-1">Private Channel ID</label>
                                <input id="channelId-settings" type="text" value={channelId} onChange={(e) => setChannelId(e.target.value)} className="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white" />
                            </div>
                            {error && <p className="text-red-400 text-sm text-center py-1">{error}</p>}
                        </div>
                        <div className="flex justify-end space-x-4 mt-6">
                            <button onClick={onClose} disabled={isSaving} className="py-2 px-4 bg-gray-600 hover:bg-gray-500 rounded-lg text-white">Cancel</button>
                            <button onClick={handleSave} disabled={isSaving} className="py-2 px-6 bg-indigo-600 hover:bg-indigo-700 rounded-lg text-white flex items-center justify-center w-24">
                                {isSaving ? <LoaderComponent small={true} /> : 'Save'}
                            </button>
                        </div>
                    </div>
                </div>
            );
        };
        
        const AuthView = () => {
            const [isLoginView, setIsLoginView] = React.useState(true);
            const [email, setEmail] = React.useState('');
            const [password, setPassword] = React.useState('');
            const [error, setError] = React.useState('');
            const [isLoading, setIsLoading] = React.useState(false);
            const [isExplanationVisible, setIsExplanationVisible] = React.useState(false);
            const handleAuthAction = async (e) => {
                e.preventDefault();
                if (!email || !password) { setError("Please enter email and password."); return; }
                setIsLoading(true); setError(''); 
                try {
                    if (isLoginView) { await auth.signInWithEmailAndPassword(email, password); } 
                    else { await auth.createUserWithEmailAndPassword(email, password); }
                } catch (err) {
                    switch (err.code) {
                        case 'auth/user-not-found': case 'auth/wrong-password': case 'auth/invalid-credential': setError("Invalid credentials. Please check your email and password."); break;
                        case 'auth/too-many-requests': setError("Too many login attempts. Please try again later."); break;
                        case 'auth/email-already-in-use': setError("An account with this email already exists. Please log in instead."); break;
                        case 'auth/weak-password': setError("Password is too weak. It should be at least 6 characters long."); break;
                        case 'auth/invalid-email': setError("The email address format is not valid."); break;
                        default: setError("An unexpected error occurred. Please try again."); break;
                    }
                } finally { setIsLoading(false); }
            };
            const ChevronIcon = ({ open }) => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={`inline-block ml-1 transition-transform duration-300 ${open ? 'rotate-180' : ''}`}><polyline points="6 9 12 15 18 9"></polyline></svg>;
            return (
                <div className="flex flex-col items-center justify-center w-full min-h-screen p-4 py-8 font-sans text-white">
                    <div className="w-full max-w-md">
                        <div className="text-center mb-8">
                            <div className="flex items-center justify-center mb-2"><LockIcon /></div>
                            <h1 className="text-4xl font-bold text-white">DaemonClient</h1>
                            <p className="text-indigo-300 mt-2">Your Secure Cloud Storage</p>
                        </div>
                        <div className="bg-gray-800 shadow-2xl rounded-xl p-8">
                            <div className="flex border-b border-gray-700 mb-6">
                                <button onClick={() => { setIsLoginView(true); setError(''); }} className={`w-1/2 py-3 text-lg font-semibold ${isLoginView ? 'text-indigo-400 border-b-2 border-indigo-400' : 'text-gray-500'}`}>Login</button>
                                <button onClick={() => { setIsLoginView(false); setError(''); }} className={`w-1/2 py-3 text-lg font-semibold ${!isLoginView ? 'text-indigo-400 border-b-2 border-indigo-400' : 'text-gray-500'}`}>Sign Up</button>
                            </div>
                            <form onSubmit={handleAuthAction} className="space-y-6">
                                <div>
                                    <label htmlFor="email-auth" className="block text-sm font-medium text-gray-300 mb-2">Email Address</label>
                                    <input id="email-auth" type="email" value={email} onChange={(e) => setEmail(e.target.value)} className="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white" required />
                                </div>
                                <div>
                                    <label htmlFor="password-auth" className="block text-sm font-medium text-gray-300 mb-2">Password</label>
                                    <input id="password-auth" type="password" value={password} onChange={(e) => setPassword(e.target.value)} className="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white" required />
                                </div>
                                {error && <p className="text-red-400 text-sm text-center">{error}</p>}
                                <div>
                                    <button type="submit" disabled={isLoading} className="w-full flex justify-center py-3 px-4 rounded-lg text-lg font-medium text-white bg-indigo-600 hover:bg-indigo-700 disabled:bg-indigo-800 disabled:opacity-75">
                                        {isLoading ? <LoaderComponent small={true} /> : (isLoginView ? 'Log In' : 'Create Account')}
                                    </button>
                                </div>
                            </form>
                        </div>
                    </div>
                    <div className="w-full max-w-2xl mt-8 text-center">
                        <button onClick={() => setIsExplanationVisible(!isExplanationVisible)} className="text-gray-400 hover:text-indigo-400 transition-colors py-2">What is DaemonClient?<ChevronIcon open={isExplanationVisible} /></button>
                        <div className={`text-left overflow-hidden transition-all duration-500 ease-in-out ${isExplanationVisible ? 'max-h-[1000px] opacity-100 mt-4' : 'max-h-0 opacity-0'}`}>
                            <div className="text-gray-300 space-y-4 bg-gray-800/50 backdrop-blur-sm p-6 rounded-lg shadow-lg border border-gray-700">
                                <p>DaemonClient is an experiment in creating secure, private, and virtually unlimited cloud storage by leveraging the Telegram API. It's a storage solution where you, and only you, control your data.</p>
                                <h3 className="text-lg font-semibold text-white pt-2">How It Works</h3>
                                <ul className="list-disc list-inside space-y-2 pl-2">
                                    <li><strong>Your Personal Cloud:</strong> It connects to a private Telegram channel that you own. All your files are stored there, accessible only by you through this client.</li>
                                    <li><strong>Secure & Private:</strong> Files are split into smaller chunks and uploaded to your private channel via your own Telegram Bot. This architecture means no one, not even the developers of this app, can access your files.</li>
                                    <li><strong>Free & Open Source:</strong> This client is completely free to use. Its source code is open, ensuring transparency and giving you full control and ownership over your data.</li>
                                </ul>
                                <p className="pt-2 text-gray-400 text-sm">This tool requires you to create your own free Telegram bot and a private channel, allowing you to maintain a zero-cost, private storage infrastructure.</p>
                                <div className="pt-5 mt-5 border-t border-gray-700 text-center"><a href="https://t.me/montclier49" target="_blank" rel="noopener noreferrer" className="text-sm text-gray-500 hover:text-indigo-400 transition-colors">A project by @montclier49</a></div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };
        
        const FileItem = ({ file, isEditing, renameValue, setRenameValue, onSaveRename, onCancelRename, onStartRename, onDownload, onDelete, isBusy }) => {
            if (isEditing) {
                return (
                    <div className="flex justify-between items-center bg-gray-900 p-3 rounded-lg">
                        <input type="text" value={renameValue} onChange={(e) => setRenameValue(e.target.value)} onKeyDown={(e) => { if (e.key === 'Enter') onSaveRename(file.id, renameValue); if (e.key === 'Escape') onCancelRename(); }} className="w-full p-1 bg-gray-700 border border-indigo-500 rounded text-white text-sm" autoFocus />
                        <div className="flex items-center space-x-2 ml-2">
                            <button onClick={() => onSaveRename(file.id, renameValue)} className="bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-3 rounded-md text-sm">Save</button>
                            <button onClick={onCancelRename} className="bg-gray-600 hover:bg-gray-500 text-white py-1 px-3 rounded-md text-sm">Cancel</button>
                        </div>
                    </div>
                );
            }
            return (
                <div className="flex justify-between items-center bg-gray-800 p-3 rounded-lg hover:bg-gray-750 transition-colors">
                    <div>
                        <p className="font-semibold text-white truncate w-40 md:w-60" title={file.fileName}>{file.fileName}</p>
                        <p className="text-xs text-gray-400">{(file.fileSize / 1024 / 1024).toFixed(2)} MB {file.uploadedAt?.toDate ? ` - ${file.uploadedAt.toDate().toLocaleDateString()}` : ''}</p>
                    </div>
                    <div className="flex items-center space-x-2">
                        <button onClick={() => onStartRename(file.id, file.fileName)} disabled={isBusy} className="text-blue-400 hover:text-blue-300 disabled:text-gray-600 disabled:cursor-not-allowed p-1" title="Rename"><RenameIcon /></button>
                        <button onClick={() => onDelete(file)} disabled={isBusy} className="bg-red-600 hover:bg-red-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-1 px-3 rounded-md text-sm">Delete</button>
                        <button onClick={() => onDownload(file)} disabled={isBusy} className="bg-green-600 hover:bg-green-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-1 px-3 rounded-md text-sm">Download</button>
                    </div>
                </div>
            );
        };

        const DashboardView = () => {
            const [config, setConfig] = React.useState(null); 
            const [isLoadingConfig, setIsLoadingConfig] = React.useState(true); 
            const [configError, setConfigError] = React.useState(''); 
            const [files, setFiles] = React.useState([]);
            const [totalFiles, setTotalFiles] = React.useState(0);
            const [isLoadingFiles, setIsLoadingFiles] = React.useState(true); 
            const [uploadProgress, setUploadProgress] = React.useState({ active: false });
            const [downloadProgress, setDownloadProgress] = React.useState({ active: false });
            const [feedbackMessage, setFeedbackMessage] = React.useState({ type: '', text: ''});
            const [isSettingsOpen, setIsSettingsOpen] = React.useState(false);
            const [isSavingSettings, setIsSavingSettings] = React.useState(false);
            const [searchTerm, setSearchTerm] = React.useState('');
            const [abortController, setAbortController] = React.useState(null);
            const [editingFileId, setEditingFileId] = React.useState(null);
            const [renameValue, setRenameValue] = React.useState('');
            const [uploadQueue, setUploadQueue] = React.useState([]);
            const [uploadBatchTotal, setUploadBatchTotal] = React.useState(0);
            const fileInputRef = React.useRef(null);
            const isUploading = uploadProgress.active;
            const isDownloading = downloadProgress.active;
            const isRenaming = editingFileId !== null;
            const isBusy = isUploading || isDownloading || isRenaming;
            const [notifications, setNotifications] = React.useState([]);
            const SettingsIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 0 2.4l-.15.08a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l-.22-.38a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1 0-2.4l.15-.08a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path><circle cx="12" cy="12" r="3"></circle></svg>;

            React.useEffect(() => {
                const currentAuthUser = auth.currentUser;
                if (currentAuthUser) {
                    const currentUserID = currentAuthUser.uid;
                    setIsLoadingConfig(true); setIsLoadingFiles(true);
                    setConfigError(''); setConfig(null); setFiles([]); 
                    const fetchData = async () => {
                        try {
                            const configPromise = db.collection(`artifacts/${appIdentifier}/users/${currentUserID}/config`).doc('telegram').get();
                            const filesPromise = db.collection(`artifacts/${appIdentifier}/users/${currentUserID}/files`).orderBy("uploadedAt", "desc").get();
                            const [configSnap, filesSnap] = await Promise.all([configPromise, filesPromise]);
                            if (configSnap.exists && configSnap.data().botToken) { setConfig(configSnap.data()); } 
                            else { setConfigError("Configuration not found. Please complete the one-time setup."); setConfig(null); }
                            const filesData = filesSnap.docs.map(d => ({ id: d.id, ...d.data() }));
                            setFiles(filesData);
                            setTotalFiles(filesData.length);
                        } catch (error) {
                            setConfigError(`Error loading data: ${error.message}. Please try refreshing the page.`);
                            setConfig(null);
                        } finally { setIsLoadingConfig(false); setIsLoadingFiles(false); }
                    };
                    fetchData();
                } else { setIsLoadingConfig(false); setIsLoadingFiles(false); setConfig(null); setFiles([]); }
            }, []); 
            
            const clearFeedback = (delay = 5000) => setTimeout(() => setFeedbackMessage({type: '', text: ''}), delay);
            const handleCancelTransfer = () => { if (abortController) { abortController.abort(); setAbortController(null); setUploadQueue([]); setUploadProgress({ active: false }); setDownloadProgress({ active: false }); setFeedbackMessage({ type: 'info', text: 'Operation cancelled.' }); clearFeedback(); } };
            
            const handleFileUpload = (e) => {
                const newFiles = e.target.files;
                if (!newFiles.length) return;
                if (!config?.botToken) {
                    setFeedbackMessage({type: 'error', text: "Bot configuration not loaded."});
                    clearFeedback();
                    return;
                }
                const newFilesArray = Array.from(newFiles);
                setUploadQueue(prevQueue => [...prevQueue, ...newFilesArray]);
                if (uploadQueue.length === 0) { setUploadBatchTotal(newFilesArray.length); } 
                else { setUploadBatchTotal(prevTotal => prevTotal + newFilesArray.length); }
                if(fileInputRef.current) fileInputRef.current.value = ""; 
            };

            React.useEffect(() => {
                if (isUploading || uploadQueue.length === 0) return; 
                const startNextUpload = async () => {
                    const fileToUpload = uploadQueue[0];
                    const controller = new AbortController();
                    setAbortController(controller);
                    const currentFileNumber = uploadBatchTotal - uploadQueue.length + 1;
                    const statusPrefix = `Uploading '${fileToUpload.name}' (${currentFileNumber}/${uploadBatchTotal})`;
                    setUploadProgress({ active: true, percent: 0, status: statusPrefix, speed: '', eta: '' });
                    setFeedbackMessage({ type: '', text: '' });
                    try {
                        const messageInfo = await uploadFile(fileToUpload, config.botToken, config.channelId, (p) => setUploadProgress(prev => ({ ...prev, ...p, status: `${statusPrefix} - ${p.status}`, active: true })), controller.signal);
                        const newFileRef = db.collection(`artifacts/${appIdentifier}/users/${auth.currentUser.uid}/files`).doc();
                        const newFileData = { id: newFileRef.id, fileName: fileToUpload.name, fileSize: fileToUpload.size, fileType: fileToUpload.type, uploadedAt: firebase.firestore.Timestamp.now(), messages: messageInfo };
                        await newFileRef.set(newFileData);
                        setFiles(prev => [newFileData, ...prev].sort((a,b) => (b.uploadedAt?.toMillis()||0) - (a.uploadedAt?.toMillis()||0)));
                        setTotalFiles(prev => prev + 1);
                        setFeedbackMessage({ type: 'success', text: `Uploaded '${fileToUpload.name}'` });
                    } catch (err) {
                        if (err.name !== 'AbortError') setFeedbackMessage({ type: 'error', text: `Upload failed for '${fileToUpload.name}': ${err.message}` });
                    } finally {
                        setUploadProgress({ active: false }); setAbortController(null);
                        const nextQueue = uploadQueue.slice(1);
                        setUploadQueue(nextQueue);
                        if (nextQueue.length === 0) { setUploadBatchTotal(0); clearFeedback(); }
                    }
                };
                startNextUpload();
            }, [uploadQueue, isUploading]); 

            const handleFileDownload = async (fileInfo) => {
                if (!config?.botToken) { setFeedbackMessage({type: 'error', text: "Bot configuration not loaded."}); clearFeedback(); return; }
                if (!fileInfo?.messages?.length) { setFeedbackMessage({type: 'error', text: "File info incomplete."}); clearFeedback(); return; }
                const controller = new AbortController(); setAbortController(controller);
                setDownloadProgress({ active: true, percent: 0, status: 'Preparing download...', speed: '', eta: '' }); setFeedbackMessage({type: '', text: ''});
                try {
                    await downloadFile(fileInfo, config.botToken, (p) => setDownloadProgress(prev => ({ ...prev, ...p, active: true })), controller.signal);
                    setFeedbackMessage({type: 'success', text: `Downloaded '${fileInfo.fileName}'`});
                } catch (err) { if (err.name !== 'AbortError') { setFeedbackMessage({type: 'error', text: `Download failed: ${err.message}`}); }
                } finally { setDownloadProgress({ active: false }); clearFeedback(); setAbortController(null); }
            };
            const handleFileDelete = async (fileToDelete) => {
                if (isBusy) return; if (!window.confirm(`Are you sure you want to delete "${fileToDelete.fileName}"? This cannot be undone.`)) return;
                setFeedbackMessage({ type: 'info', text: `Deleting '${fileToDelete.fileName}'...` });
                try {
                    await deleteTelegramMessages(config.botToken, config.channelId, fileToDelete.messages);
                    await db.collection(`artifacts/${appIdentifier}/users/${auth.currentUser.uid}/files`).doc(fileToDelete.id).delete();
                    setFiles(prev => prev.filter(f => f.id !== fileToDelete.id));
                    setTotalFiles(prev => prev - 1);
                    setFeedbackMessage({ type: 'success', text: `Successfully deleted '${fileToDelete.fileName}'.` });
                } catch (err) { setFeedbackMessage({ type: 'error', text: `Failed to delete file: ${err.message}` });
                } finally { clearFeedback(); }
            };
            const handleStartRename = (fileId, currentName) => { if (isBusy) return; setEditingFileId(fileId); setRenameValue(currentName); };
            const handleCancelRename = () => { setEditingFileId(null); setRenameValue(''); };
            const handleSaveRename = async (fileId, newName) => {
                const trimmedName = newName.trim();
                if (!trimmedName) { setFeedbackMessage({ type: 'error', text: 'File name cannot be empty.' }); clearFeedback(3000); return; }
                const originalFile = files.find(f => f.id === fileId);
                if (originalFile.fileName === trimmedName) { handleCancelRename(); return; }
                try {
                    const fileRef = db.collection(`artifacts/${appIdentifier}/users/${auth.currentUser.uid}/files`).doc(fileId);
                    await fileRef.update({ fileName: trimmedName });
                    setFiles(prevFiles => prevFiles.map(f => f.id === fileId ? { ...f, fileName: trimmedName } : f));
                    setFeedbackMessage({ type: 'success', text: 'File renamed successfully!' });
                } catch (error) { setFeedbackMessage({ type: 'error', text: `Failed to rename file: ${error.message}` });
                } finally { handleCancelRename(); clearFeedback(); }
            };
            const handleLogout = async () => { try { await auth.signOut(); } catch (err) { setFeedbackMessage({type: 'error', text: "Logout failed."}); clearFeedback(); }};
            const handleSaveSettings = async (newConfig) => {
                setIsSavingSettings(true);
                const configDocRef = db.collection(`artifacts/${appIdentifier}/users/${auth.currentUser.uid}/config`).doc('telegram');
                try {
                    await configDocRef.update({ botToken: newConfig.botToken, channelId: newConfig.channelId });
                    setConfig(prev => ({...prev, ...newConfig}));
                    setIsSettingsOpen(false);
                    setFeedbackMessage({type: 'success', text: 'Settings updated successfully!'});
                    clearFeedback();
                } catch (error) { throw error;
                } finally { setIsSavingSettings(false); }
            };

            if (isLoadingConfig || isLoadingFiles) return <FullScreenLoader message={isLoadingConfig ? "Loading Configuration..." : "Loading Files..."} />;
            if (configError) return (<div className="min-h-screen bg-gray-900 text-white flex items-center justify-center p-4"><div className="w-full max-w-3xl bg-gray-800 rounded-xl shadow-2xl p-6"><div className="flex justify-between items-center mb-4"><h1 className="text-3xl font-bold text-indigo-400">DaemonClient</h1><button onClick={handleLogout} className="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg text-sm">Logout</button></div><div className="p-4 bg-red-700 text-red-100 rounded-lg"><h2 className="text-xl font-semibold mb-2">Configuration Error</h2><p>{configError}</p><p className="mt-2">Try logging out and back in.</p></div></div></div>);
            const filteredFiles = files.filter(file => file.fileName.toLowerCase().includes(searchTerm.toLowerCase()));

            return (
                <div className="min-h-screen bg-gray-900 text-white flex items-center justify-center p-4 font-sans">
                    <div className="w-full max-w-3xl bg-gray-800 rounded-xl shadow-2xl p-6">
                        <div className="flex justify-between items-center mb-4">
                            <h1 className="text-3xl font-bold text-indigo-400">DaemonClient</h1>
                            <div className="flex items-center space-x-4">
                                <button onClick={() => setIsSettingsOpen(true)} className="text-gray-400 hover:text-white" title="Settings"><SettingsIcon /></button>
                                <button onClick={handleLogout} className="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg text-sm">Logout</button>
                            </div>
                        </div>
                        <div className="bg-gray-700 p-4 rounded-lg mb-4">
                            <h2 className="text-xl font-semibold mb-2">Upload Files</h2>
                            <input type="file" ref={fileInputRef} onChange={handleFileUpload} className="hidden" disabled={isBusy} multiple />
                            <button onClick={() => fileInputRef.current.click()} disabled={isBusy} className="w-full bg-indigo-500 hover:bg-indigo-600 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded-lg mt-2">
                                {isUploading ? 'Uploading...' : 'Choose Files to Upload'}
                            </button>
                        </div>
                        {isUploading && <ProgressBar {...uploadProgress} onCancel={handleCancelTransfer} />}
                        <div className="bg-gray-700 p-4 rounded-lg mt-4">
                            <div className="flex justify-between items-center mb-4">
                                <h2 className="text-xl font-semibold">Your Files ({totalFiles})</h2>
                                <div className="w-1/2"><input type="text" placeholder="Search files..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className="w-full p-2 bg-gray-800 border border-gray-600 rounded-lg text-white text-sm" disabled={isBusy} /></div>
                            </div>
                            <div className="mt-2 space-y-2 max-h-60 overflow-y-auto pr-2">{ !isLoadingFiles && filteredFiles.length > 0 ? filteredFiles.map(file => (<FileItem key={file.id} file={file} isEditing={editingFileId === file.id} renameValue={renameValue} setRenameValue={setRenameValue} onStartRename={handleStartRename} onCancelRename={handleCancelRename} onSaveRename={handleSaveRename} onDownload={handleFileDownload} onDelete={handleFileDelete} isBusy={isBusy && editingFileId !== file.id} /> )) : (<p className="text-center text-gray-400 py-4">{isLoadingFiles ? 'Loading...' : 'No files found.'}</p>)}</div>
                        </div>
                        {isDownloading && <ProgressBar {...downloadProgress} onCancel={handleCancelTransfer} />}
                        {feedbackMessage.text && <div className={`mt-4 p-3 rounded-lg text-sm text-center ${feedbackMessage.type === 'error' ? 'bg-red-900 text-red-200' : feedbackMessage.type === 'success' ? 'bg-green-900 text-green-200' : 'bg-blue-900 text-blue-200'}`}>{feedbackMessage.text}</div>}
                        {!isUploading && !isDownloading && !feedbackMessage.text && <div className="h-12 mt-4"></div> }
                    </div>
                    {isSettingsOpen && config && <SettingsModal initialConfig={config} onSave={handleSaveSettings} onClose={() => setIsSettingsOpen(false)} isSaving={isSavingSettings} />}
                </div>
            );
        };

        // ============================================================================
        // --- SETUP VIEW (MODIFIED) ---
        // ============================================================================
        const SetupView = ({ onSetupInitiated }) => {
            const [showManualForm, setShowManualForm] = React.useState(false);
            const [statusMessage, setStatusMessage] = React.useState('');
            const [botToken, setBotToken] = React.useState('');
            const [channelId, setChannelId] = React.useState('');
            const [error, setError] = React.useState('');
            const [isLoading, setIsLoading] = React.useState(false);

            const handleStartAutomatedSetup = async () => {
                setStatusMessage('Initiating secure setup... This may take a minute.');
                setError('');
                setIsLoading(true);
                try {
                    const response = await fetch('http://127.0.0.1:8080/startSetup', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            data: { uid: auth.currentUser.uid, email: auth.currentUser.email }
                        })
                    });
                    const result = await response.json();
                    if (!response.ok) {
                        throw new Error(result.error?.message || 'The setup service returned an unspecified error.');
                    }
                    // On success, simply call the parent component's handler to switch views.
                    onSetupInitiated();
                } catch (err) {
                    console.error("Error during setup process:", err);
                    setStatusMessage('');
                    setError(`Setup initiation failed: ${err.message}. Please try again.`);
                    setIsLoading(false);
                }
            };

            const handleSaveManualSetup = async () => {
                if (!botToken.trim() || !channelId.trim()) { setError("Bot Token and Channel ID are required."); return; }
                setIsLoading(true); setError('');
                try {
                    const configDocRef = db.collection(`artifacts/${appIdentifier}/users/${auth.currentUser.uid}/config`).doc('telegram');
                    await configDocRef.set({ 
                        botToken: botToken.trim(), 
                        channelId: channelId.trim(), 
                        setupTimestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        ownership_transferred: true, // Manual setup implies user already owns them.
                        setup_type: 'manual'
                    });
                    // For manual setup, we consider it fully complete and go to the dashboard.
                    onSetupInitiated({ manual: true });
                } catch (err) { setError(`Save failed: ${err.message}`); }
                finally { setIsLoading(false); }
            };

            const handleLogout = async () => { try { await auth.signOut(); } catch (err) { /* silent fail */ }};
            const AutomatedSetupPanel = () => (
                <div className="bg-gray-900 border-2 border-indigo-500 rounded-lg p-6 relative">
                    <span className="absolute top-0 right-4 -mt-3 bg-indigo-500 text-white text-xs font-bold px-3 py-1 rounded-full">Recommended</span>
                    <h2 className="text-xl font-semibold text-white">Automated Setup</h2>
                    <p className="text-gray-400 mt-2 text-sm">The easiest way to get started. We'll automatically create and configure a private bot and channel for you.</p>
                    <button onClick={handleStartAutomatedSetup} disabled={isLoading || !!statusMessage} className="mt-6 w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center text-lg disabled:bg-gray-600 disabled:cursor-not-allowed">
                        {isLoading ? <LoaderComponent /> : 'Create My Secure Storage'}
                    </button>
                </div>
            );
            const ManualSetupPanel = () => ( <div className="bg-gray-700 rounded-lg p-6"> <h2 className="text-xl font-semibold text-white">Manual Setup</h2> <p className="text-gray-400 mt-2 text-sm">For advanced users who want to use their own existing bot and channel.</p> <button onClick={() => setShowManualForm(true)} className="mt-4 w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg flex items-center justify-center">Enter Credentials Manually</button> </div> );
            const ManualSetupForm = () => ( <div className="mt-8 animate-fade-in"> <h2 className="text-xl font-semibold text-center text-white mb-4">Enter Your Credentials</h2> <div className="space-y-6"> <div> <label htmlFor="botToken-setup" className="block text-sm font-medium text-gray-300 mb-1">Telegram Bot Token</label> <input id="botToken-setup" type="password" value={botToken} onChange={(e) => setBotToken(e.target.value)} className="w-full p-3 bg-gray-600 border border-gray-500 rounded-lg text-white" placeholder="From @BotFather" /> </div> <div> <label htmlFor="channelId-setup" className="block text-sm font-medium text-gray-300 mb-1">Private Channel ID</label> <input id="channelId-setup" type="text" value={channelId} onChange={(e) => setChannelId(e.target.value)} className="w-full p-3 bg-gray-600 border border-gray-500 rounded-lg text-white" placeholder="From @userinfobot" /> </div> {error && <p className="text-red-400 text-sm text-center py-2">{error}</p>} <button onClick={handleSaveManualSetup} disabled={isLoading} className="w-full bg-indigo-500 hover:bg-indigo-600 disabled:bg-indigo-800 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center text-lg"> {isLoading ? <LoaderComponent small={true} /> : 'Save & Continue'} </button> <button onClick={() => setShowManualForm(false)} className="w-full text-center text-gray-400 hover:text-white text-sm mt-4">Back to setup options</button> </div> </div> );
            const StatusBar = ({message}) => ( <div className="mt-8 p-4 bg-gray-900 rounded-lg flex items-center justify-center animate-fade-in"> <LoaderComponent small={true} /> <p className="ml-4 text-indigo-300">{message}</p> </div> );

            return (
                <div className="min-h-screen bg-gray-900 text-white flex flex-col items-center justify-center p-4 font-sans">
                    <div className="w-full max-w-2xl">
                        <div className="bg-gray-800 rounded-xl shadow-2xl p-6 md:p-8 relative overflow-hidden">
                            <div className="text-center mb-8">
                                <h1 className="text-3xl font-bold text-indigo-400">One-Time Setup</h1>
                                <p className="text-gray-400 mt-2">Let's create your private, secure storage.</p>
                            </div>
                            {showManualForm ? <ManualSetupForm /> : (<div className="space-y-8"><AutomatedSetupPanel /><ManualSetupPanel /></div>)}
                            {statusMessage && <StatusBar message={statusMessage} />}
                            {error && !statusMessage && <p className="text-red-400 text-center mt-4">{error}</p>}
                        </div>
                        <div className="text-center mt-6">
                            <button onClick={handleLogout} className="text-sm text-gray-500 hover:text-gray-300">Logout</button>
                        </div>
                    </div>
                </div>
            );
        };

    // ============================================================================
    // --- OWNERSHIP VIEW (REDESIGNED FOR A MULTI-STEP FLOW) ---
    // ============================================================================
    const OwnershipView = ({ onOwnershipConfirmed }) => {
        const [config, setConfig] = React.useState(null);
        const [step, setStep] = React.useState(1); // 1 = start bot, 2 = join channel, 3 = processing
        const [isLoading, setIsLoading] = React.useState(true);
        const [error, setError] = React.useState('');
        const [countdown, setCountdown] = React.useState(5);
        const [isButtonDisabled, setIsButtonDisabled] = React.useState(true);
        const [transferStatus, setTransferStatus] = React.useState(null);

        // Fetch the config once on component mount
        React.useEffect(() => {
            const fetchConfig = async () => {
                try {
                    const configDocRef = db.collection(`artifacts/${appIdentifier}/users/${auth.currentUser.uid}/config`).doc('telegram');
                    const docSnap = await configDocRef.get();
                    if (docSnap.exists) {
                        setConfig(docSnap.data());
                    } else {
                        setError("Could not find your configuration. Please try the setup again.");
                    }
                } catch (err) {
                    setError("Error fetching configuration: " + err.message);
                } finally {
                    setIsLoading(false);
                }
            };
            fetchConfig();
        }, []);

        // This effect manages the countdown timer for each step
        React.useEffect(() => {
            setIsButtonDisabled(true);
            setCountdown(5); // Reset countdown for each new step
            const interval = setInterval(() => {
                setCountdown(prev => {
                    if (prev <= 1) {
                        clearInterval(interval);
                        setIsButtonDisabled(false);
                        return 0;
                    }
                    return prev - 1;
                });
            }, 1000);
            return () => clearInterval(interval);
        }, [step]); // Rerun this effect whenever the step changes

        const handleFinalize = async () => {
            setStep(3); // Move to the processing view
            setError('');
            setTransferStatus({
                bot: { status: 'pending', message: 'Verifying and transferring bot ownership...' },
                channel: { status: 'pending', message: 'Attempting to transfer channel ownership...' }
            });
            try {
                const response = await fetch('http://127.0.0.1:8080/finalizeTransfer', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ data: { uid: auth.currentUser.uid } })
                });
                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.error?.message || 'The server returned an unspecified error.');
                }
                
                setTransferStatus({
                    bot: { status: result.bot_transfer_status, message: result.bot_transfer_message },
                    channel: { status: result.channel_transfer_status, message: result.channel_transfer_message }
                });
                
                setTimeout(() => onOwnershipConfirmed(), 5000);

            } catch (err) {
                setError(`A critical error occurred: ${err.message}`);
                setStep(2); // Go back to the last step on error
            }
        };

        const StatusItem = ({ status, message }) => {
            const icon = status === 'pending' ? <LoaderComponent small={true} /> :
                         status === 'success' ? <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-green-400"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg> :
                         <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-red-400"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>;
            const textColor = status === 'success' ? 'text-green-300' : status === 'failed' ? 'text-red-300' : 'text-gray-300';

            return <li className="flex items-start space-x-3 py-2"><div className="flex-shrink-0 mt-1">{icon}</div><p className={`${textColor} text-sm`}>{message}</p></li>;
        };

        if (isLoading) {
            return <FullScreenLoader message="Loading your bot and channel details..." />;
        }
        
        const renderStepContent = () => {
            switch (step) {
                case 1:
                    return (
                        <div className="space-y-6 text-center">
                             <h1 className="text-3xl font-bold text-indigo-400">Final Step (1/2): Start Your Bot</h1>
                             <p className="text-gray-400">This is required by Telegram to transfer ownership. Click the link, press START in Telegram, then come back here.</p>
                             <a href={config ? `https://t.me/${config.botUsername}` : '#'} target="_blank" className="inline-block bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg text-lg">
                                 {config ? `Open Bot: @${config.botUsername}` : <LoaderComponent small={true} />}
                             </a>
                             <button onClick={() => setStep(2)} disabled={isButtonDisabled} className="w-full max-w-xs mx-auto bg-indigo-600 hover:bg-indigo-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center text-lg">
                                {isButtonDisabled ? `Next Step (${countdown}s)` : 'Next Step'}
                             </button>
                        </div>
                    );
                case 2:
                    return (
                        <div className="space-y-6 text-center">
                            <h1 className="text-3xl font-bold text-indigo-400">Final Step (2/2): Join Your Channel</h1>
                            <p className="text-gray-400">This allows us to securely identify you as the owner. Click the link to join, then come back and finalize.</p>
                            <a href={config ? config.invite_link : '#'} target="_blank" className="inline-block bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg text-lg">
                                {config ? 'Join Secure Channel' : <LoaderComponent small={true} />}
                            </a>
                            <button onClick={handleFinalize} disabled={isButtonDisabled} className="w-full max-w-xs mx-auto bg-green-600 hover:bg-green-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center text-lg">
                                {isButtonDisabled ? `Finalize (${countdown}s)` : 'Finalize Transfer'}
                            </button>
                        </div>
                    );
                case 3:
                     return (
                        <div>
                            <h1 className="text-3xl font-bold text-indigo-400 text-center mb-4">Finalizing Setup...</h1>
                            <ul className="space-y-2 bg-gray-900 p-4 rounded-lg">
                                <StatusItem status={transferStatus.bot.status} message={transferStatus.bot.message} />
                                <StatusItem status={transferStatus.channel.status} message={transferStatus.channel.message} />
                            </ul>
                        </div>
                    );
                default:
                    return null;
            }
        };

        return (
            <div className="min-h-screen bg-gray-900 text-white flex flex-col items-center justify-center p-4 font-sans">
                <div className="w-full max-w-xl bg-gray-800 rounded-xl shadow-2xl p-6 md:p-8">
                    {renderStepContent()}
                    {error && <p className="text-red-400 text-sm text-center mt-4">{error}</p>}
                </div>
            </div>
        );
    };


        // ============================================================================
        // --- MAIN APP COMPONENT (REWRITTEN) ---
        // ============================================================================
        function App() {
            const [user, setUser] = React.useState(null);
            const [appState, setAppState] = React.useState('loading'); // loading, auth, setup, transfer, dashboard

            React.useEffect(() => {
                const unsubscribe = auth.onAuthStateChanged(async (currentUser) => {
                    if (!currentUser) {
                        setAppState('auth');
                        return;
                    }
                    setUser(currentUser);
                    try {
                        const configDocRef = db.collection(`artifacts/${appIdentifier}/users/${currentUser.uid}/config`).doc('telegram');
                        const docSnap = await configDocRef.get();

                        if (!docSnap.exists) {
                            setAppState('setup');
                        } else {
                            const configData = docSnap.data();
                            if (configData.ownership_transferred) {
                                setAppState('dashboard');
                            } else {
                                // This case handles if a user creates resources but closes the browser
                                // before entering their username.
                                setAppState('transfer');
                            }
                        }
                    } catch (error) { 
                        console.error("[App] Error checking setup status:", error);
                        setAppState('setup'); // Default to setup on error
                    }
                });
                return () => unsubscribe(); 
            }, []); 

            // Handlers to change state from child components
            const handleSetupInitiated = (opts = {}) => {
                if (opts.manual) {
                    setAppState('dashboard'); // Manual setup goes straight to dashboard
                } else {
                    setAppState('transfer');
                }
            };

            const handleOwnershipConfirmed = () => {
                setAppState('dashboard');
            };

            // Render based on state
            switch (appState) {
                case 'loading':
                    return <FullScreenLoader message="Initializing App..." />;
                case 'auth':
                    return <AuthView />;
                case 'setup':
                    return <SetupView onSetupInitiated={handleSetupInitiated} />;
                case 'transfer':
                    return <OwnershipView onOwnershipConfirmed={handleOwnershipConfirmed} />;
                case 'dashboard':
                    return <DashboardView />;
                default:
                    return <AuthView />;
            }
        }

        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);

        </script>
    </body>
    </html>