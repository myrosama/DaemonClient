<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Basic Meta Tags -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">

    <!-- SEO Meta Tags for Google -->
    <title>DaemonClient: Free, Unlimited & Private Cloud Storage</title>
    <meta name="description" content="DaemonClient is a zero-knowledge cloud platform that transforms your personal Telegram account into a secure, private, and virtually limitless file vault. True data ownership, at zero cost.">
    <meta name="keywords" content="cloud storage, private storage, secure, decentralized, telegram, zero-cost, file hosting, privacy, data ownership, free cloud storage">
    <meta name="author" content="DaemonClient">
    <link rel="canonical" href="https://daemonclient.uz/">

    <!-- Open Graph / Facebook / Discord Meta Tags -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://daemonclient.uz/">
    <meta property="og:title" content="DaemonClient: Free, Unlimited & Private Cloud Storage">
    <meta property="og:description" content="A zero-knowledge cloud platform that transforms your personal Telegram account into a secure, private, and virtually limitless file vault.">
    <meta property="og:image" content="https://daemonclient.uz/og-image.png">
    <meta property="og:site_name" content="DaemonClient: Free, Unlimited & Private Cloud Storage">

    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://daemonclient.uz/">
    <meta name="twitter:title" content="DaemonClient: Free, Unlimited & Private Cloud Storage">
    <meta name="twitter:description" content="A zero-knowledge cloud platform that transforms your personal Telegram account into a secure, private, and virtually limitless file vault.">
    <meta name="twitter:image" content="https://daemonclient.uz/og-image.png">

    <!-- All your other scripts below... -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-functions.js"></script>
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7486772209560079"
     crossorigin="anonymous"></script>

</head>
<body class="bg-gray-900">
    <div id="root"></div>

    <script type="text/babel">
    // --- Firebase Initialization ---
    const firebaseConfig = {
  apiKey: "AIzaSyBH5diC5M7MnOIuOWaNPmOB1AV6uJVZyS8",
  authDomain: "daemonclient-c0625.firebaseapp.com",
  databaseURL: "https://daemonclient-c0625-default-rtdb.firebaseio.com",
  projectId: "daemonclient-c0625",
  storageBucket: "daemonclient-c0625.firebasestorage.app",
  messagingSenderId: "424457448611",
  appId: "1:424457448611:web:bea9f7673fb40f137de316",
  measurementId: "G-72V5NJ7F2C"
};

    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    const appIdentifier = 'default-daemon-client'; 

    // ============================================================================
    // --- HELPER FUNCTIONS & OTHER COMPONENTS (Unchanged) ---
    // ============================================================================
    const CHUNK_SIZE = 19 * 1024 * 1024;
    const UPLOAD_RETRIES = 10;
    const DOWNLOAD_RETRIES = 5;
    const PROACTIVE_DELAY_MS = 1000;
    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
    function formatSpeed(bytes) { if (!bytes || bytes < 1024 || isNaN(bytes)) return `...`; if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(2)} KB/s`; return `${(bytes / (1024 * 1024)).toFixed(2)} MB/s`; }
    function formatETA(seconds) { if (seconds === Infinity || isNaN(seconds) || seconds < 1) return '...'; const h = Math.floor(seconds / 3600); const m = Math.floor((seconds % 3600) / 60); const s = Math.floor(seconds % 60); return [h > 0 ? `${h}h` : '', m > 0 ? `${m}m` : '', s > 0 ? `${s}s` : (h===0 && m===0 ? '0s' : '')].filter(Boolean).join(' ') || '...'; }
    async function uploadFile(file, botToken, channelId, onProgress, abortSignal) {
        const totalParts = Math.ceil(file.size / CHUNK_SIZE);
        const uploadedMessageInfo = [];
        let uploadedBytes = 0;
        const startTime = Date.now();
        for (let i = 0; i < totalParts; i++) {
            if (abortSignal.aborted) throw new Error("Upload was cancelled by the user.");
            const partNumber = i + 1;
            const chunk = file.slice(i * CHUNK_SIZE, (i + 1) * CHUNK_SIZE);
            let success = false;
            for (let attempt = 1; attempt <= UPLOAD_RETRIES; attempt++) {
                if (abortSignal.aborted) throw new Error("Upload was cancelled by the user.");
                try {
                    const elapsedTime = (Date.now() - startTime) / 1000 || 1;
                    const speed = uploadedBytes / elapsedTime;
                    const remainingBytes = file.size - uploadedBytes;
                    const eta = (speed > 0 && remainingBytes > 0) ? remainingBytes / speed : Infinity;
                    onProgress({ percent: Math.round((uploadedBytes / file.size) * 100), status: `Uploading part ${partNumber}/${totalParts} (Attempt ${attempt})`, speed: formatSpeed(speed), eta: formatETA(eta) });
                    const formData = new FormData();
                    formData.append('chat_id', channelId);
                    formData.append('document', chunk, `${file.name}.part${String(partNumber).padStart(3, '0')}`);
                    const response = await fetch(`https://api.telegram.org/bot${botToken}/sendDocument`, { method: 'POST', body: formData, signal: abortSignal });
                    const result = await response.json();
                    if (result.ok) {
                        uploadedMessageInfo.push({ message_id: result.result.message_id, file_id: result.result.document.file_id });
                        uploadedBytes += chunk.size;
                        success = true;
                        break; 
                    } else {
                        if (response.status === 429 && result.parameters?.retry_after) {
                            const retryAfter = parseInt(result.parameters.retry_after, 10);
                            onProgress(prev => ({ ...prev, status: `Rate limited. Waiting ${retryAfter}s...` }));
                            await sleep(retryAfter * 1000 + 500);
                        } else { await sleep(2000 * attempt); }
                    }
                } catch (error) {
                    if (error.name === 'AbortError') throw error;
                    if (attempt >= UPLOAD_RETRIES) throw new Error(`Part ${partNumber} failed after ${UPLOAD_RETRIES} attempts: ${error.message}`);
                    await sleep(3000 * attempt);
                }
            } 
            if (!success) throw new Error(`Upload failed for part ${partNumber}. All retries exhausted.`);
            if (partNumber < totalParts) await sleep(PROACTIVE_DELAY_MS);
        } 
        onProgress({ percent: 100, status: `Upload complete!`, speed: '', eta: ''});
        return uploadedMessageInfo;
    }
        // ============================================================================
    // --- DOWNLOAD FUNCTION (Ultimate Version: Concurrent Streaming to Disk) ---
    // ============================================================================
    async function downloadFile(fileInfo, botToken, onProgress, abortSignal) {
        // Constants from your original code. CHUNK_SIZE must match the one used for uploads.
        const { messages, fileName, fileSize, fileType } = fileInfo;
        const CHUNK_SIZE = 19 * 1024 * 1024; // Ensure this matches your upload CHUNK_SIZE
        const DOWNLOAD_RETRIES = 5;
        const CONCURRENT_DOWNLOADS = 5;

        const totalParts = messages.length;
        let downloadedBytes = 0;
        let completedParts = 0;
        const startTime = Date.now();

        // --- Step 1: Check for browser support ---
        if (!window.showSaveFilePicker) {
            const errorMessage = 'Error: Your browser does not support high-performance downloads. Please use the latest version of Chrome, Edge, or Opera.';
            onProgress({ percent: 0, status: errorMessage, speed: '', eta: '' });
            alert(errorMessage);
            throw new Error("File System Access API not supported.");
        }

        // --- Step 2: Get user permission and a file handle ---
        let fileHandle;
        try {
            onProgress({ percent: 0, status: 'Waiting for permission...', speed: '', eta: '' });
            fileHandle = await window.showSaveFilePicker({ suggestedName: fileName });
        } catch (err) {
            if (err.name === 'AbortError') {
                onProgress({ active: false }); // Reset UI if user cancels
                return; 
            }
            throw err;
        }

        // --- Step 3: Create a writable stream to the local file ---
        const writable = await fileHandle.createWritable();

        // --- Step 4: Define the download logic for a single part ---
        async function downloadPartWithRetry(partData) {
            for (let attempt = 1; attempt <= DOWNLOAD_RETRIES; attempt++) {
                if (abortSignal.aborted) throw new Error("Download was cancelled by the user.");
                try {
                    const fileInfoUrl = `https://api.telegram.org/bot${botToken}/getFile?file_id=${partData.file_id}`;
                    const fileInfoRes = await fetch(fileInfoUrl, { signal: abortSignal });
                    const fileInfoData = await fileInfoRes.json();
                    if (!fileInfoData.ok) {
                        // Handle Telegram rate limits gracefully
                        if (fileInfoData.error_code === 429 && fileInfoData.parameters?.retry_after) {
                            const waitTime = fileInfoData.parameters.retry_after;
                            onProgress(prev => ({ ...prev, status: `Rate limited. Waiting ${waitTime}s...` }));
                            await sleep(waitTime * 1000 + 500);
                            continue; // Retry the same attempt after waiting
                        }
                        throw new Error(`TG getFile error: ${fileInfoData.description || "Unknown"}`);
                    }
                    
                    const filePath = fileInfoData.result.file_path;
                    // The lightweight proxy is still needed to bypass CORS.
                    const proxyUrl = new URL('https://us-central1-daemonclient-c0625.cloudfunctions.net/telegramDownloadProxy');
                    proxyUrl.searchParams.append('botToken', botToken);
                    proxyUrl.searchParams.append('filePath', filePath);
                    
                    const fileRes = await fetch(proxyUrl.toString(), { signal: abortSignal });
                    if (!fileRes.ok) throw new Error(`Proxy error ${fileRes.status}: ${await fileRes.text()}`);
                    
                    // Return the raw data as an ArrayBuffer, perfect for writing to a file.
                    return await fileRes.arrayBuffer();

                } catch (error) {
                    if (error.name === 'AbortError') throw error;
                    if (attempt >= DOWNLOAD_RETRIES) throw error;
                    await sleep(2000 * attempt);
                }
            }
        }

        // --- Step 5: Set up and manage the concurrent download queue ---
        return new Promise((resolve, reject) => {
            const queue = [...messages.entries()]; // [index, partData]

            const worker = async () => {
                while (queue.length > 0) {
                    if (abortSignal.aborted) {
                        await writable.abort();
                        reject(new Error("Download was cancelled."));
                        return;
                    }

                    const [index, partData] = queue.shift();
                    
                    try {
                        const chunkData = await downloadPartWithRetry(partData);
                        
                        // NINJA TECHNIQUE: Write the downloaded chunk to its specific position in the file.
                        const position = index * CHUNK_SIZE;
                        await writable.write({ type: 'write', position: position, data: chunkData });

                        // Update progress based on actual data received
                        downloadedBytes += chunkData.byteLength;
                        completedParts++;

                        const elapsedTime = (Date.now() - startTime) / 1000 || 1;
                        const speed = downloadedBytes / elapsedTime;
                        const remainingBytes = fileSize - downloadedBytes;
                        const eta = (remainingBytes > 0 && speed > 0) ? remainingBytes / speed : 0;
                        
                        onProgress({ 
                            percent: Math.round((downloadedBytes / fileSize) * 100), 
                            status: `Downloaded part ${completedParts}/${totalParts}...`, 
                            speed: formatSpeed(speed), 
                            eta: formatETA(eta) 
                        });
                        
                        // Check if the entire file is complete
                        if (completedParts === totalParts) {
                            await writable.close();
                            onProgress({ percent: 100, status: `Download complete! File saved.`, speed: '', eta: '' });
                            resolve();
                            return; // Exit the worker
                        }
                    } catch (error) {
                        await writable.abort(); // Clean up the file on error
                        reject(error);
                        return; // Stop this worker on failure
                    }
                }
            };

            // Start all concurrent workers
            onProgress({ percent: 0, status: 'Starting download...', speed: '', eta: '' });
            for (let i = 0; i < CONCURRENT_DOWNLOADS; i++) {
                worker();
            }
        });
    }
    async function deleteTelegramMessages(botToken, channelId, messages) {
        for (const message of messages) {
            try {
                await fetch(`https://api.telegram.org/bot${botToken}/deleteMessage`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ chat_id: channelId, message_id: message.message_id })
                });
            } catch (error) { console.error(`Network error deleting message ${message.message_id}:`, error); }
            await sleep(350);
        }
    }
    const LoaderComponent = ({ small }) => <div className={`animate-spin rounded-full border-b-2 border-white ${small ? 'h-6 w-6' : 'h-10 w-10'}`}></div>;
    const LockIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="mr-2 h-10 w-10 text-indigo-400"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>;
    const LogoComponent = () => <img src="/logo.png" alt="DaemonClient Logo" className="h-16 w-auto" />; 
    const FullScreenLoader = ({message}) => <div className="flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white"><LoaderComponent /><p className="mt-4 text-lg">{message || "Loading Application..."}</p></div>;
    const RenameIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>;
    const ProgressBar = ({ percent, statit, speed, eta, onCancel }) => (
        <div className="w-full mt-4">
            <div className="flex justify-between items-center mb-1 text-xs text-gray-300">
                <span>{status}</span>
                <div className="flex items-center">
                    <span className="mr-4">{eta || '...'}</span>
                    {onCancel && <button onClick={onCancel} className="text-red-400 hover:text-red-300 text-xs font-bold">CANCEL</button>}
                </div>
            </div>
            <div className="w-full bg-gray-600 rounded-full h-2.5"><div className="bg-indigo-500 h-2.5 rounded-full" style={{ width: `${percent}%` }}></div></div>
            <div className="text-center text-sm font-semibold text-indigo-300 mt-1">{speed || '...'}</div>
        </div>
    );
    const SettingsModal = ({ initialConfig, onSave, onClose, isSaving }) => {
        const [botToken, setBotToken] = React.useState(initialConfig.botToken || '');
        const [channelId, setChannelId] = React.useState(initialConfig.channelId || '');
        const [error, setError] = React.useState('');
        const handleSave = async () => {
            if (!botToken.trim() || !channelId.trim()) { setError("Bot Token and Channel ID cannot be empty."); return; }
            setError('');
            try { await onSave({ botToken, channelId }); } catch (err) { setError(`Save failed: ${err.message}`); }
        };
        return (
            <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 font-sans">
                <div className="bg-gray-800 rounded-xl shadow-2xl p-8 w-full max-w-lg">
                    <h2 className="text-2xl font-bold text-indigo-400 mb-4">Settings</h2>
                    <div className="space-y-4">
                        <div>
                            <label htmlFor="botToken-settings" className="block text-sm font-medium text-gray-300 mb-1">Telegram Bot Token</label>
                            <input id="botToken-settings" type="password" value={botToken} onChange={(e) => setBotToken(e.target.value)} className="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white" />
                        </div>
                        <div>
                            <label htmlFor="channelId-settings" className="block text-sm font-medium text-gray-300 mb-1">Private Channel ID</label>
                            <input id="channelId-settings" type="text" value={channelId} onChange={(e) => setChannelId(e.target.value)} className="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white" />
                        </div>
                        {error && <p className="text-red-400 text-sm text-center py-1">{error}</p>}
                    </div>
                    <div className="flex justify-end space-x-4 mt-6">
                        <button onClick={onClose} disabled={isSaving} className="py-2 px-4 bg-gray-600 hover:bg-gray-500 rounded-lg text-white">Cancel</button>
                        <button onClick={handleSave} disabled={isSaving} className="py-2 px-6 bg-indigo-600 hover:bg-indigo-700 rounded-lg text-white flex items-center justify-center w-24">
                            {isSaving ? <LoaderComponent small={true} /> : 'Save'}
                        </button>
                    </div>
                </div>
            </div>
        );
    };
        const AuthView = () => {
        const [isLoginView, setIsLoginView] = React.useState(true);
        const [email, setEmail] = React.useState('');
        const [password, setPassword] = React.useState('');
        const [error, setError] = React.useState('');
        const [isLoading, setIsLoading] = React.useState(false);
        const [isExplanationVisible, setIsExplanationVisible] = React.useState(false);
        
        // --- States for the Terms of Use modal ---
        const [isTermsModalOpen, setIsTermsModalOpen] = React.useState(false);
        const [hasAgreedToTerms, setHasAgreedToTerms] = React.useState(false);

        const handleAuthAction = async (e) => {
            e.preventDefault();
            
            // --- Validation logic combined correctly ---
            if (!isLoginView && !hasAgreedToTerms) {
                setError("You must agree to the Terms of Use to create an account.");
                return; // Stop the function here
            }
            if (!email || !password) {
                setError("Please enter email and password.");
                return; // Stop the function here
            }
            
            setIsLoading(true);
            setError(''); 
            
            try {
                if (isLoginView) {
                    await auth.signInWithEmailAndPassword(email, password);
                } else {
                    await auth.createUserWithEmailAndPassword(email, password);
                }
            } catch (err) {
                switch (err.code) {
                    case 'auth/user-not-found':
                    case 'auth/wrong-password':
                    case 'auth/invalid-credential':
                        setError("Invalid credentials. Please check your email and password.");
                        break;
                    case 'auth/too-many-requests':
                        setError("Too many login attempts. Please try again later.");
                        break;
                    case 'auth/email-already-in-use':
                        setError("An account with this email already exists. Please log in instead.");
                        break;
                    case 'auth/weak-password':
                        setError("Password is too weak. It should be at least 6 characters long.");
                        break;
                    case 'auth/invalid-email':
                        setError("The email address format is not valid.");
                        break;
                    default:
                        setError("An unexpected error occurred. Please try again.");
                        break;
                }
            } finally {
                setIsLoading(false);
            }
        };

        const ChevronIcon = ({ open }) => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={`inline-block ml-1 transition-transform duration-300 ${open ? 'rotate-180' : ''}`}><polyline points="6 9 12 15 18 9"></polyline></svg>;
        
        return (
                <div className="flex flex-col items-center justify-center w-full min-h-screen p-4 py-8 font-sans text-white">
                <div className="w-full max-w-md">
                    <div className="text-center mb-8">
                        <div className="flex items-center justify-center mb-2">
                     {/* --- THIS IS THE CHANGE --- */}
                        <LogoComponent />
                     </div>
                        <h1 className="text-4xl font-bold text-white">DaemonClient</h1>
                        <p className="text-indigo-300 mt-2">Your Secure Cloud Storage</p>
                    </div>
                    <div className="bg-gray-800 shadow-2xl rounded-xl p-8">
                        <div className="flex border-b border-gray-700 mb-6">
                            <button onClick={() => { setIsLoginView(true); setError(''); }} className={`w-1/2 py-3 text-lg font-semibold ${isLoginView ? 'text-indigo-400 border-b-2 border-indigo-400' : 'text-gray-500'}`}>Login</button>
                            <button onClick={() => { setIsLoginView(false); setError(''); }} className={`w-1/2 py-3 text-lg font-semibold ${!isLoginView ? 'text-indigo-400 border-b-2 border-indigo-400' : 'text-gray-500'}`}>Sign Up</button>
                        </div>
                        <form onSubmit={handleAuthAction} className="space-y-6">
                            <div>
                                <label htmlFor="email-auth" className="block text-sm font-medium text-gray-300 mb-2">Email Address</label>
                                <input id="email-auth" type="email" value={email} onChange={(e) => setEmail(e.target.value)} className="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white" required />
                            </div>
                            <div>
                                <label htmlFor="password-auth" className="block text-sm font-medium text-gray-300 mb-2">Password</label>
                                <input id="password-auth" type="password" value={password} onChange={(e) => setPassword(e.target.value)} className="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white" required />
                            </div>
                            
                            {/* --- NEW: TERMS AGREEMENT CHECKBOX (only for Sign Up view) --- */}
                            {!isLoginView && (
                                <div className="flex items-center">
                                    <input 
                                        id="terms-agree" 
                                        type="checkbox" 
                                        checked={hasAgreedToTerms} 
                                        onChange={(e) => setHasAgreedToTerms(e.target.checked)}
                                        className="h-4 w-4 rounded border-gray-500 bg-gray-700 text-indigo-600 focus:ring-indigo-500"
                                    />
                                    <label htmlFor="terms-agree" className="ml-2 block text-sm text-gray-300">
                                        I agree to the{' '}
                                        <button 
                                            type="button" 
                                            onClick={() => setIsTermsModalOpen(true)} 
                                            className="font-medium text-indigo-400 hover:text-indigo-300"
                                        >
                                            Terms of Use
                                        </button>
                                    </label>
                                </div>
                            )}

                            {error && <p className="text-red-400 text-sm text-center">{error}</p>}
                            <div>
                                <button type="submit" disabled={isLoading || (!isLoginView && !hasAgreedToTerms)} className="w-full flex justify-center py-3 px-4 rounded-lg text-lg font-medium text-white bg-indigo-600 hover:bg-indigo-700 disabled:bg-indigo-800 disabled:opacity-75">
                                    {isLoading ? <LoaderComponent small={true} /> : (isLoginView ? 'Log In' : 'Create Account')}
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
                <div className="w-full max-w-2xl mt-8 text-center">
                    <button onClick={() => setIsExplanationVisible(!isExplanationVisible)} className="text-gray-400 hover:text-indigo-400 transition-colors py-2">What is DaemonClient?<ChevronIcon open={isExplanationVisible} /></button>
                    <div className={`text-left overflow-hidden transition-all duration-500 ease-in-out ${isExplanationVisible ? 'max-h-[1000px] opacity-100 mt-4' : 'max-h-0 opacity-0'}`}>
                        <div className="text-gray-300 space-y-4 bg-gray-800/50 backdrop-blur-sm p-6 rounded-lg shadow-lg border border-gray-700">
                            <p>DaemonClient is a novel, zero-knowledge cloud storage platform that transforms your personal Telegram account into a secure, private, and virtually limitless file vault.</p>
                            <h3 className="text-lg font-semibold text-white pt-2">How It Works: A Decentralized Architecture</h3>
                            <ul className="list-disc list-inside space-y-2 pl-2">
                                <li><strong>True Privacy:</strong> Your files are chunked, encrypted in transit, and stored in a private Telegram channel that only you and your personal bot can access. The DaemonClient developers have zero ability to see or access your files.</li>
                                <li><strong>Zero Cost:</strong> By leveraging Telegram's generous file storage policies, this architecture provides terabytes of storage at no cost.</li>
                                <li><strong>Full Control:</strong> You own the storage infrastructure. All file operations are managed client-side, directly between your browser and the Telegram API, ensuring your data never passes through our servers after the initial setup.</li>
                            </ul>
                            <p className="pt-2 text-gray-400 text-sm">This tool requires you to create your own free Telegram bot and a private channel, allowing you to maintain a zero-cost, private storage infrastructure.</p>
                            <div className="pt-5 mt-5 border-t border-gray-700 text-center"><a href="https://t.me/montclier49" target="_blank" rel="noopener noreferrer" className="text-sm text-gray-500 hover:text-indigo-400 transition-colors">A project by @montclier49</a></div>
                        </div>
                    </div>
                </div>

                {/* --- RENDER THE MODAL IF OPEN --- */}
                {isTermsModalOpen && <TermsModal onClose={() => setIsTermsModalOpen(false)} />}
            </div>
        );
    };
    const FileItem = ({ file, isEditing, renameValue, setRenameValue, onSaveRename, onCancelRename, onStartRename, onDownload, onDelete, isBusy }) => {
        if (isEditing) {
            return (
                <div className="flex justify-between items-center bg-gray-900 p-3 rounded-lg">
                    <input type="text" value={renameValue} onChange={(e) => setRenameValue(e.target.value)} onKeyDown={(e) => { if (e.key === 'Enter') onSaveRename(file.id, renameValue); if (e.key === 'Escape') onCancelRename(); }} className="w-full p-1 bg-gray-700 border border-indigo-500 rounded text-white text-sm" autoFocus />
                    <div className="flex items-center space-x-2 ml-2">
                        <button onClick={() => onSaveRename(file.id, renameValue)} className="bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-3 rounded-md text-sm">Save</button>
                        <button onClick={onCancelRename} className="bg-gray-600 hover:bg-gray-500 text-white py-1 px-3 rounded-md text-sm">Cancel</button>
                    </div>
                </div>
            );
        }
        return (
            <div className="flex justify-between items-center bg-gray-800 p-3 rounded-lg hover:bg-gray-750 transition-colors">
                <div>
                    <p className="font-semibold text-white truncate w-40 md:w-60" title={file.fileName}>{file.fileName}</p>
                    <p className="text-xs text-gray-400">{(file.fileSize / 1024 / 1024).toFixed(2)} MB {file.uploadedAt?.toDate ? ` - ${file.uploadedAt.toDate().toLocaleDateString()}` : ''}</p>
                </div>
                <div className="flex items-center space-x-2">
                    <button onClick={() => onStartRename(file.id, file.fileName)} disabled={isBusy} className="text-blue-400 hover:text-blue-300 disabled:text-gray-600 disabled:cursor-not-allowed p-1" title="Rename"><RenameIcon /></button>
                    <button onClick={() => onDelete(file)} disabled={isBusy} className="bg-red-600 hover:bg-red-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-1 px-3 rounded-md text-sm">Delete</button>
                    <button onClick={() => onDownload(file)} disabled={isBusy} className="bg-green-600 hover:bg-green-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-1 px-3 rounded-md text-sm">Download</button>
                </div>
            </div>
        );
    };

    // ============================================================================
    // --- DASHBOARD VIEW (Updated for Multi-File Upload) ---
    // ============================================================================
    const DashboardView = () => {
        const [config, setConfig] = React.useState(null); 
        const [isLoadingConfig, setIsLoadingConfig] = React.useState(true); 
        const [configError, setConfigError] = React.useState(''); 
        const [files, setFiles] = React.useState([]);
        const [totalFiles, setTotalFiles] = React.useState(0);
        const [isLoadingFiles, setIsLoadingFiles] = React.useState(true); 
        const [uploadProgress, setUploadProgress] = React.useState({ active: false });
        const [downloadProgress, setDownloadProgress] = React.useState({ active: false });
        const [feedbackMessage, setFeedbackMessage] = React.useState({ type: '', text: ''});
        const [isSettingsOpen, setIsSettingsOpen] = React.useState(false);
        const [isSavingSettings, setIsSavingSettings] = React.useState(false);
        const [searchTerm, setSearchTerm] = React.useState('');
        const [abortController, setAbortController] = React.useState(null);
        const [editingFileId, setEditingFileId] = React.useState(null);
        const [renameValue, setRenameValue] = React.useState('');
        
        // ✅ 1. State for the upload queue
        const [uploadQueue, setUploadQueue] = React.useState([]);
        const [uploadBatchTotal, setUploadBatchTotal] = React.useState(0);

        const fileInputRef = React.useRef(null);
        const isUploading = uploadProgress.active;
        const isDownloading = downloadProgress.active;
        const isRenaming = editingFileId !== null;
        const isBusy = isUploading || isDownloading || isRenaming;
        const SettingsIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 0 2.4l-.15.08a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l-.22-.38a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1 0-2.4l.15-.08a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path><circle cx="12" cy="12" r="3"></circle></svg>;

        React.useEffect(() => {
            const currentAuthUser = auth.currentUser;
            if (currentAuthUser) {
                const currentUserID = currentAuthUser.uid;
                setIsLoadingConfig(true); setIsLoadingFiles(true);
                setConfigError(''); setConfig(null); setFiles([]); 
                const fetchData = async () => {
                    try {
                        const configPromise = db.collection(`artifacts/${appIdentifier}/users/${currentUserID}/config`).doc('telegram').get();
                        const filesPromise = db.collection(`artifacts/${appIdentifier}/users/${currentUserID}/files`).orderBy("uploadedAt", "desc").get();
                        const [configSnap, filesSnap] = await Promise.all([configPromise, filesPromise]);
                        if (configSnap.exists && configSnap.data().botToken) { setConfig(configSnap.data()); } 
                        else { setConfigError("Configuration not found. Please complete the one-time setup."); setConfig(null); }
                        const filesData = filesSnap.docs.map(d => ({ id: d.id, ...d.data() }));
                        setFiles(filesData);
                        setTotalFiles(filesData.length);
                    } catch (error) {
                        setConfigError(`Error loading data: ${error.message}. Please try refreshing the page.`);
                        setConfig(null);
                    } finally { setIsLoadingConfig(false); setIsLoadingFiles(false); }
                };
                fetchData();
            } else { setIsLoadingConfig(false); setIsLoadingFiles(false); setConfig(null); setFiles([]); }
        }, []); 
        
        const clearFeedback = (delay = 5000) => setTimeout(() => setFeedbackMessage({type: '', text: ''}), delay);
        const handleCancelTransfer = () => { if (abortController) { abortController.abort(); setAbortController(null); setUploadQueue([]); setUploadProgress({ active: false }); setDownloadProgress({ active: false }); setFeedbackMessage({ type: 'info', text: 'Operation cancelled.' }); clearFeedback(); } };
        
        // ✅ 2. handleFileUpload now adds files to the queue
        const handleFileUpload = (e) => {
            const newFiles = e.target.files;
            if (!newFiles.length) return;
            if (!config?.botToken) {
                setFeedbackMessage({type: 'error', text: "Bot configuration not loaded."});
                clearFeedback();
                return;
            }
            const newFilesArray = Array.from(newFiles);
            setUploadQueue(prevQueue => [...prevQueue, ...newFilesArray]);
            if (uploadQueue.length === 0) { // If this is the start of a new batch
                setUploadBatchTotal(newFilesArray.length);
            } else {
                setUploadBatchTotal(prevTotal => prevTotal + newFilesArray.length);
            }

            if(fileInputRef.current) fileInputRef.current.value = ""; 
        };

        // ✅ 3. This useEffect processes the upload queue one by one
        React.useEffect(() => {
            if (isUploading || uploadQueue.length === 0) {
                return; // Do nothing if already uploading or queue is empty
            }

            const startNextUpload = async () => {
                const fileToUpload = uploadQueue[0];
                const controller = new AbortController();
                setAbortController(controller);
                
                const currentFileNumber = uploadBatchTotal - uploadQueue.length + 1;
                const statusPrefix = `Uploading '${fileToUpload.name}' (${currentFileNumber}/${uploadBatchTotal})`;

                setUploadProgress({ active: true, percent: 0, status: statusPrefix, speed: '', eta: '' });
                setFeedbackMessage({ type: '', text: '' });

                try {
                    const messageInfo = await uploadFile(
                        fileToUpload, 
                        config.botToken, 
                        config.channelId, 
                        (p) => setUploadProgress(prev => ({ ...prev, ...p, status: `${statusPrefix} - ${p.status}`, active: true })), 
                        controller.signal
                    );

                    const newFileRef = db.collection(`artifacts/${appIdentifier}/users/${auth.currentUser.uid}/files`).doc();
                    const newFileData = { id: newFileRef.id, fileName: fileToUpload.name, fileSize: fileToUpload.size, fileType: fileToUpload.type, uploadedAt: firebase.firestore.Timestamp.now(), messages: messageInfo };
                    await newFileRef.set(newFileData);

                    setFiles(prev => [newFileData, ...prev].sort((a,b) => (b.uploadedAt?.toMillis()||0) - (a.uploadedAt?.toMillis()||0)));
                    setTotalFiles(prev => prev + 1);
                    setFeedbackMessage({ type: 'success', text: `Uploaded '${fileToUpload.name}'` });
                
                } catch (err) {
                    if (err.name !== 'AbortError') {
                        setFeedbackMessage({ type: 'error', text: `Upload failed for '${fileToUpload.name}': ${err.message}` });
                    }
                } finally {
                    setUploadProgress({ active: false });
                    setAbortController(null);
                    // Remove the processed file and move to the next one
                    const nextQueue = uploadQueue.slice(1);
                    setUploadQueue(nextQueue);
                    if (nextQueue.length === 0) {
                        setUploadBatchTotal(0); // Reset batch total when queue is done
                        clearFeedback();
                    }
                }
            };

            startNextUpload();
        }, [uploadQueue, isUploading]); // This hook runs when the queue or upload status changes

        const handleFileDownload = async (fileInfo) => {
            if (!config?.botToken) { setFeedbackMessage({type: 'error', text: "Bot configuration not loaded."}); clearFeedback(); return; }
            if (!fileInfo?.messages?.length) { setFeedbackMessage({type: 'error', text: "File info incomplete."}); clearFeedback(); return; }
            const controller = new AbortController(); setAbortController(controller);
            setDownloadProgress({ active: true, percent: 0, status: 'Preparing download...', speed: '', eta: '' }); setFeedbackMessage({type: '', text: ''});
            try {
                await downloadFile(fileInfo, config.botToken, (p) => setDownloadProgress(prev => ({ ...prev, ...p, active: true })), controller.signal);
                setFeedbackMessage({type: 'success', text: `Downloaded '${fileInfo.fileName}'`});
            } catch (err) { if (err.name !== 'AbortError') { setFeedbackMessage({type: 'error', text: `Download failed: ${err.message}`}); }
            } finally { setDownloadProgress({ active: false }); clearFeedback(); setAbortController(null); }
        };
        const handleFileDelete = async (fileToDelete) => {
            if (isBusy) return; if (!window.confirm(`Are you sure you want to delete "${fileToDelete.fileName}"? This cannot be undone.`)) return;
            setFeedbackMessage({ type: 'info', text: `Deleting '${fileToDelete.fileName}'...` });
            try {
                await deleteTelegramMessages(config.botToken, config.channelId, fileToDelete.messages);
                await db.collection(`artifacts/${appIdentifier}/users/${auth.currentUser.uid}/files`).doc(fileToDelete.id).delete();
                setFiles(prev => prev.filter(f => f.id !== fileToDelete.id));
                setTotalFiles(prev => prev - 1);
                setFeedbackMessage({ type: 'success', text: `Successfully deleted '${fileToDelete.fileName}'.` });
            } catch (err) { setFeedbackMessage({ type: 'error', text: `Failed to delete file: ${err.message}` });
            } finally { clearFeedback(); }
        };
        const handleStartRename = (fileId, currentName) => { if (isBusy) return; setEditingFileId(fileId); setRenameValue(currentName); };
        const handleCancelRename = () => { setEditingFileId(null); setRenameValue(''); };
        const handleSaveRename = async (fileId, newName) => {
            const trimmedName = newName.trim();
            if (!trimmedName) { setFeedbackMessage({ type: 'error', text: 'File name cannot be empty.' }); clearFeedback(3000); return; }
            const originalFile = files.find(f => f.id === fileId);
            if (originalFile.fileName === trimmedName) { handleCancelRename(); return; }
            try {
                const fileRef = db.collection(`artifacts/${appIdentifier}/users/${auth.currentUser.uid}/files`).doc(fileId);
                await fileRef.update({ fileName: trimmedName });
                setFiles(prevFiles => prevFiles.map(f => f.id === fileId ? { ...f, fileName: trimmedName } : f));
                setFeedbackMessage({ type: 'success', text: 'File renamed successfully!' });
            } catch (error) { setFeedbackMessage({ type: 'error', text: `Failed to rename file: ${error.message}` });
            } finally { handleCancelRename(); clearFeedback(); }
        };
        const handleLogout = async () => { try { await auth.signOut(); } catch (err) { setFeedbackMessage({type: 'error', text: "Logout failed."}); clearFeedback(); }};
        const handleSaveSettings = async (newConfig) => {
            setIsSavingSettings(true);
            const configDocRef = db.collection(`artifacts/${appIdentifier}/users/${auth.currentUser.uid}/config`).doc('telegram');
            try {
                await configDocRef.update({ botToken: newConfig.botToken, channelId: newConfig.channelId });
                setConfig(prev => ({...prev, ...newConfig}));
                setIsSettingsOpen(false);
                setFeedbackMessage({type: 'success', text: 'Settings updated successfully!'});
                clearFeedback();
            } catch (error) { throw error;
            } finally { setIsSavingSettings(false); }
        };

        if (isLoadingConfig || isLoadingFiles) return <FullScreenLoader message={isLoadingConfig ? "Loading Configuration..." : "Loading Files..."} />;
        if (configError) return (<div className="min-h-screen bg-gray-900 text-white flex items-center justify-center p-4"><div className="w-full max-w-3xl bg-gray-800 rounded-xl shadow-2xl p-6"><div className="flex justify-between items-center mb-4"><h1 className="text-3xl font-bold text-indigo-400">DaemonClient</h1><button onClick={handleLogout} className="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg text-sm">Logout</button></div><div className="p-4 bg-red-700 text-red-100 rounded-lg"><h2 className="text-xl font-semibold mb-2">Configuration Error</h2><p>{configError}</p><p className="mt-2">Try logging out and back in.</p></div></div></div>);
        const filteredFiles = files.filter(file => file.fileName.toLowerCase().includes(searchTerm.toLowerCase()));

        return (
            <div className="min-h-screen bg-gray-900 text-white flex items-center justify-center p-4 font-sans">
                <div className="w-full max-w-3xl bg-gray-800 rounded-xl shadow-2xl p-6">
                    <div className="flex justify-between items-center mb-4">
                        <h1 className="text-3xl font-bold text-indigo-400">DaemonClient</h1>
                        <div className="flex items-center space-x-4">
                            <button onClick={() => setIsSettingsOpen(true)} className="text-gray-400 hover:text-white" title="Settings"><SettingsIcon /></button>
                            <button onClick={handleLogout} className="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg text-sm">Logout</button>
                        </div>
                    </div>
                    <div className="bg-gray-700 p-4 rounded-lg mb-4">
                        <h2 className="text-xl font-semibold mb-2">Upload Files</h2>
                        {/* ✅ 4. The input now accepts multiple files */}
                        <input type="file" ref={fileInputRef} onChange={handleFileUpload} className="hidden" disabled={isBusy} multiple />
                        <button onClick={() => fileInputRef.current.click()} disabled={isBusy} className="w-full bg-indigo-500 hover:bg-indigo-600 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded-lg mt-2">
                            {isUploading ? 'Uploading...' : 'Choose Files to Upload'}
                        </button>
                    </div>

                    {/* ✅ 5. The progress bar UI is enhanced for queue status */}
                    {isUploading && <ProgressBar {...uploadProgress} onCancel={handleCancelTransfer} />}

                    <div className="bg-gray-700 p-4 rounded-lg mt-4">
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-xl font-semibold">Your Files ({totalFiles})</h2>
                            <div className="w-1/2"><input type="text" placeholder="Search files..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className="w-full p-2 bg-gray-800 border border-gray-600 rounded-lg text-white text-sm" disabled={isBusy} /></div>
                        </div>
                        <div className="mt-2 space-y-2 max-h-60 overflow-y-auto pr-2">{ !isLoadingFiles && filteredFiles.length > 0 ? filteredFiles.map(file => (<FileItem key={file.id} file={file} isEditing={editingFileId === file.id} renameValue={renameValue} setRenameValue={setRenameValue} onStartRename={handleStartRename} onCancelRename={handleCancelRename} onSaveRename={handleSaveRename} onDownload={handleFileDownload} onDelete={handleFileDelete} isBusy={isBusy && editingFileId !== file.id} /> )) : (<p className="text-center text-gray-400 py-4">{isLoadingFiles ? 'Loading...' : 'No files found.'}</p>)}</div>
                    </div>
                    {isDownloading && <ProgressBar {...downloadProgress} onCancel={handleCancelTransfer} />}
                    {feedbackMessage.text && <div className={`mt-4 p-3 rounded-lg text-sm text-center ${feedbackMessage.type === 'error' ? 'bg-red-900 text-red-200' : feedbackMessage.type === 'success' ? 'bg-green-900 text-green-200' : 'bg-blue-900 text-blue-200'}`}>{feedbackMessage.text}</div>}
                    {!isUploading && !isDownloading && !feedbackMessage.text && <div className="h-12 mt-4"></div> }
                </div>
                {isSettingsOpen && config && <SettingsModal initialConfig={config} onSave={handleSaveSettings} onClose={() => setIsSettingsOpen(false)} isSaving={isSavingSettings} />}
            </div>
        );
    };
        // ============================================================================
    // --- NEW: Terms of Use Modal Component ---
    // ============================================================================
    const TermsModal = ({ onClose }) => {
        return (
            <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 font-sans" onClick={onClose}>
                <div className="bg-gray-800 rounded-xl shadow-2xl p-8 w-full max-w-3xl max-h-[80vh] overflow-y-auto" onClick={(e) => e.stopPropagation()}>
                    <h2 className="text-2xl font-bold text-indigo-400 mb-4">Terms of Use for DaemonClient</h2>
                    <div className="text-gray-300 space-y-4 text-sm">
                        <p className="text-gray-400">Last Updated: September 19, 2025</p>
                        
                        <h3 className="font-semibold text-white pt-2">1. The Service</h3>
                        <p>DaemonClient ("the Service") is a software tool that allows users to leverage their personal Telegram account as a cloud storage backend. The Service is provided "as-is" without any warranties. We are not a file-hosting company; we provide a tool for you to manage your own storage.</p>

                        <h3 className="font-semibold text-white pt-2">2. User Responsibility and Data Ownership</h3>
                        <p>You, the user, are solely responsible for the data you store using the Service. All files are stored in a private Telegram channel and managed by a Telegram bot to which you are given full ownership. We, the developers, have zero-knowledge of or access to your stored files.</p>
                        <p>You agree not to use the Service to store any content that is illegal, infringes on copyright, or violates Telegram's Terms of Service.</p>

                        <h3 className="font-semibold text-white pt-2">3. Platform Dependency and Risk of Data Loss</h3>
                        <p>The Service is critically dependent on the APIs and policies of third-party platforms, primarily Telegram. These platforms may change their services, policies, or APIs at any time without notice. Such changes could render DaemonClient partially or completely non-functional, potentially leading to the loss of access to your data. By using the Service, you acknowledge and accept this risk. We are not liable for any data loss resulting from third-party platform changes.</p>

                        <h3 className="font-semibold text-white pt-2">4. Limitation of Liability</h3>
                        <p>In no event shall the developers of DaemonClient be liable for any direct, indirect, special, incidental, or consequential damages arising out of the use or inability to use the Service, including but not limited to data loss, even if we have been advised of the possibility of such damages.</p>

                        <h3 className="font-semibold text-white pt-2">5. Termination</h3>
                        <p>We reserve the right to terminate your access to the Service's authentication system at any time if you are found to be in violation of these terms.</p>
                        
                        <div className="text-center pt-4">
                            <button onClick={onClose} className="py-2 px-6 bg-indigo-600 hover:bg-indigo-700 rounded-lg text-white">Close</button>
                        </div>
                    </div>
                    
                </div>
            </div>
        );
    };
    // ============================================================================
    // --- SETUP VIEW (Unchanged) ---
    // ============================================================================
    const SetupView = ({ onSetupComplete }) => {
        const [showManualForm, setShowManualForm] = React.useState(false);
        const [statusMessage, setStatusMessage] = React.useState('');
        const [botToken, setBotToken] = React.useState('');
        const [channelId, setChannelId] = React.useState('');
        const [error, setError] = React.useState('');
        const [isLoading, setIsLoading] = React.useState(false);

        const handleStartAutomatedSetup = async () => {
            setStatusMessage('Initiating secure setup... This may take a minute.');
            setError('');
            setIsLoading(true);
            try {
                const response = await fetch('http://127.0.0.1:8080/startSetup', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        data: {
                            uid: auth.currentUser.uid,
                            email: auth.currentUser.email,
                        }
                    })
                });
                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.error?.message || 'The setup service returned an unspecified error.');
                }
                setStatusMessage("Finalizing configuration...");
                const configDocRef = db.collection(`artifacts/${appIdentifier}/users/${auth.currentUser.uid}/config`).doc('telegram');
                let attempts = 0;
                const maxAttempts = 5;
                while (attempts < maxAttempts) {
                    const docSnap = await configDocRef.get();
                    // This is the new, correct logic
                    if (docSnap.exists && docSnap.data().botToken) {
                        setStatusMessage('Configuration saved! Proceeding to final step...');
                        // No more setTimeout. We call the function immediately to switch pages.
                        onSetupComplete(); 
                        return;
                    }
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    attempts++;
                }
                throw new Error("Could not verify configuration after setup. Please try again.");
            } catch (err) {
                console.error("Error during setup process:", err);
                setStatusMessage('');
                if (err.message.includes('Failed to fetch')) {
                    setError(`Could not connect to the setup service. Please try again later.`);
                } else {
                    setError(`An unexpected error occurred. Please try again or contact support.`);
                }
            } finally {
                setIsLoading(false);
            }
        };

        const handleSaveManualSetup = async () => {
            if (!botToken.trim() || !channelId.trim()) { setError("Bot Token and Channel ID are required."); return; }
            setIsLoading(true); setError('');
            try {
                const configDocRef = db.collection(`artifacts/${appIdentifier}/users/${auth.currentUser.uid}/config`).doc('telegram');
                await configDocRef.set({ botToken: botToken.trim(), channelId: channelId.trim(), setupTimestamp: firebase.firestore.FieldValue.serverTimestamp() });
                onSetupComplete();
            } catch (err) { setError(`Save failed: ${err.message}`); }
            finally { setIsLoading(false); }
        };

        const handleLogout = async () => { try { await auth.signOut(); } catch (err) { /* silent fail */ }};
        
        React.useEffect(() => {
            const uid = auth.currentUser?.uid;
            if (!uid) return;
            const unsubscribe = db.collection(`artifacts/${appIdentifier}/users/${uid}/config`).doc('telegram')
                .onSnapshot((doc) => {
                    if (doc.exists && doc.data().botToken) {
                        setStatusMessage('Setup complete! Redirecting to your dashboard...');
                        setTimeout(() => onSetupComplete(), 1500);
                    }
                });
            return () => unsubscribe();
        }, [onSetupComplete]);
        
        const AutomatedSetupPanel = () => (
             <div className="bg-gray-900 border-2 border-indigo-500 rounded-lg p-6 relative">
                <span className="absolute top-0 right-4 -mt-3 bg-indigo-500 text-white text-xs font-bold px-3 py-1 rounded-full">Recommended</span>
                <h2 className="text-xl font-semibold text-white">Automated Setup</h2>
                <p className="text-gray-400 mt-2 text-sm">The easiest way to get started. We'll automatically create and configure a private bot and channel for you.</p>
                <button onClick={handleStartAutomatedSetup} disabled={isLoading || !!statusMessage} className="mt-6 w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center text-lg disabled:bg-gray-600 disabled:cursor-not-allowed">
                    {isLoading ? <LoaderComponent /> : 'Create My Secure Storage'}
                </button>
            </div>
        );

        const ManualSetupPanel = () => (
            <div className="bg-gray-700 rounded-lg p-6">
                 <h2 className="text-xl font-semibold text-white">Manual Setup</h2>
                 <p className="text-gray-400 mt-2 text-sm">For advanced users who want to use their own existing bot and channel.</p>
                <button onClick={() => setShowManualForm(true)} className="mt-4 w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg flex items-center justify-center">Enter Credentials Manually</button>
            </div>
        );

        const ManualSetupForm = () => (
            <div className="mt-8 animate-fade-in">
                <h2 className="text-xl font-semibold text-center text-white mb-4">Enter Your Credentials</h2>
                 <div className="space-y-6">
                    <div>
                        <label htmlFor="botToken-setup" className="block text-sm font-medium text-gray-300 mb-1">Telegram Bot Token</label>
                        <input id="botToken-setup" type="password" value={botToken} onChange={(e) => setBotToken(e.target.value)} className="w-full p-3 bg-gray-600 border border-gray-500 rounded-lg text-white" placeholder="From @BotFather" />
                    </div>
                    <div>
                        <label htmlFor="channelId-setup" className="block text-sm font-medium text-gray-300 mb-1">Private Channel ID</label>
                        <input id="channelId-setup" type="text" value={channelId} onChange={(e) => setChannelId(e.target.value)} className="w-full p-3 bg-gray-600 border border-gray-500 rounded-lg text-white" placeholder="From @userinfobot" />
                    </div>
                    {error && <p className="text-red-400 text-sm text-center py-2">{error}</p>}
                    <button onClick={handleSaveManualSetup} disabled={isLoading} className="w-full bg-indigo-500 hover:bg-indigo-600 disabled:bg-indigo-800 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center text-lg">
                        {isLoading ? <LoaderComponent small={true} /> : 'Save & Continue'}
                    </button>
                    <button onClick={() => setShowManualForm(false)} className="w-full text-center text-gray-400 hover:text-white text-sm mt-4">Back to setup options</button>
                </div>
            </div>
        );
        
        const StatusBar = ({message}) => (
             <div className="mt-8 p-4 bg-gray-900 rounded-lg flex items-center justify-center animate-fade-in">
                <LoaderComponent small={true} />
                <p className="ml-4 text-indigo-300">{message}</p>
             </div>
        );

        return (
            <div className="min-h-screen bg-gray-900 text-white flex flex-col items-center justify-center p-4 font-sans">
                <div className="w-full max-w-2xl">
                    <div className="bg-gray-800 rounded-xl shadow-2xl p-6 md:p-8 relative overflow-hidden">
                        <div className="text-center mb-8">
                            <h1 className="text-3xl font-bold text-indigo-400">One-Time Setup</h1>
                            <p className="text-gray-400 mt-2">Let's create your private, secure storage.</p>
                        </div>
                        {showManualForm ? <ManualSetupForm /> : (<div className="space-y-8"><AutomatedSetupPanel /><ManualSetupPanel /></div>)}
                        {statusMessage && <StatusBar message={statusMessage} />}
                        {error && !statusMessage && <p className="text-red-400 text-center mt-4">{error}</p>}
                    </div>
                     <div className="text-center mt-6">
                        <button onClick={handleLogout} className="text-sm text-gray-500 hover:text-gray-300">Logout</button>
                    </div>
                </div>
            </div>
        );
    };

        // ============================================================================
    // --- OWNERSHIP VIEW (REDESIGNED FOR YOUR SUPERIOR MULTI-STEP FLOW) ---
    // ============================================================================
    const OwnershipView = ({ onOwnershipConfirmed }) => {
        const [config, setConfig] = React.useState(null);
        const [step, setStep] = React.useState(1); // 1 = start bot, 2 = join channel, 3 = processing
        const [isLoading, setIsLoading] = React.useState(true);
        const [error, setError] = React.useState('');
        const [countdown, setCountdown] = React.useState(10);
        const [isButtonDisabled, setIsButtonDisabled] = React.useState(true);
        const [hasClickedLink, setHasClickedLink] = React.useState(false);
        const [isProcessing, setIsProcessing] = React.useState(false);
        const [transferStatus, setTransferStatus] = React.useState(null);

        // Fetch the config once on component mount
        React.useEffect(() => {
            const fetchConfig = async () => {
                try {
                    const configDocRef = db.collection(`artifacts/${appIdentifier}/users/${auth.currentUser.uid}/config`).doc('telegram');
                    const docSnap = await configDocRef.get();
                    if (docSnap.exists) {
                        setConfig(docSnap.data());
                    } else {
                        setError("Could not find your configuration. Please try the setup again.");
                    }
                } catch (err) {
                    setError("Error fetching configuration: " + err.message);
                } finally {
                    setIsLoading(false);
                }
            };
            fetchConfig();
        }, []);

        // This effect manages the countdown timer for each new step
        React.useEffect(() => {
            if (isLoading) return; // Don't start timers while loading config
            
            setIsButtonDisabled(true); // Always disable button at the start of a step
            setCountdown(10); // Reset countdown for each new step
            
            // This flag is to ensure the user must click the link before the timer starts
            if (hasClickedLink) {
                const interval = setInterval(() => {
                    setCountdown(prev => {
                        if (prev <= 1) {
                            clearInterval(interval);
                            setIsButtonDisabled(false);
                            return 0;
                        }
                        return prev - 1;
                    });
                }, 1000);
                return () => clearInterval(interval);
            }
        }, [step, hasClickedLink, isLoading]);

        const handleLinkClicked = () => {
            if (!hasClickedLink) {
                setHasClickedLink(true);
            }
        };
        
        const handleNextStep = () => {
            setStep(2);
            setHasClickedLink(false); // Reset for the next step
        }

        const handleFinalize = async () => {
            setIsProcessing(true); // Use a different state for the final API call
            setStep(3); // Move to the processing view
            setError('');
            setTransferStatus({
                bot: { status: 'pending', message: 'Verifying user and transferring bot ownership...' },
                channel: { status: 'pending', message: 'Attempting to transfer channel ownership...' }
            });
            try {
                const response = await fetch('http://127.0.0.1:8080/finalizeTransfer', { // Make sure this URL is your live Render URL
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ data: { uid: auth.currentUser.uid } })
                });
                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.error?.message || 'The server returned an unspecified error.');
                }
                
                setTransferStatus({
                    bot: { status: result.bot_transfer_status, message: result.bot_transfer_message },
                    channel: { status: result.channel_transfer_status, message: result.channel_transfer_message }
                });
                
                setTimeout(() => onOwnershipConfirmed(), 5000);

            } catch (err) {
                setError(`A critical error occurred: ${err.message}`);
                setStep(2); // Go back to the last step on error
                setIsProcessing(false);
                setHasClickedLink(false);
            }
        };

        const StatusItem = ({ status, message }) => {
            const icon = status === 'pending' ? <LoaderComponent small={true} /> :
                         status === 'success' ? <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-green-400"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg> :
                         <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-red-400"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>;
            const textColor = status === 'success' ? 'text-green-300' : status === 'failed' ? 'text-red-300' : 'text-gray-300';

            return <li className="flex items-start space-x-3 py-2"><div className="flex-shrink-0 mt-1">{icon}</div><p className={`${textColor} text-sm`}>{message}</p></li>;
        };

        if (isLoading) {
            return <FullScreenLoader message="Loading your bot and channel details..." />;
        }
        
        const renderStepContent = () => {
            switch (step) {
                case 1:
                    return (
                        <div className="space-y-6 text-center">
                             <h1 className="text-3xl font-bold text-indigo-400">Final Step (1/2): Start Your Bot</h1>
                             <p className="text-gray-400">This is required by Telegram to transfer ownership. Click the link, press START in Telegram, then come back here.</p>
                             <a 
                                href={config ? `https://t.me/${config.botUsername}` : '#'} 
                                target="_blank" 
                                onClick={handleLinkClicked}
                                className="inline-block bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg text-lg"
                             >
                                 {config ? `Open Bot: @${config.botUsername}` : <LoaderComponent small={true} />}
                             </a>
                             <button onClick={handleNextStep} disabled={isButtonDisabled} className="w-full max-w-xs mx-auto bg-indigo-600 hover:bg-indigo-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center text-lg">
                                {isButtonDisabled ? `Next Step (${countdown}s)` : 'Next Step'}
                             </button>
                        </div>
                    );
                case 2:
                    return (
                        <div className="space-y-6 text-center">
                            <h1 className="text-3xl font-bold text-indigo-400">Final Step (2/2): Join Your Channel</h1>
                            <p className="text-gray-400">This allows us to securely identify you as the owner. Click the link to join, then come back and finalize.</p>
                            <a 
                                href={config ? config.invite_link : '#'} 
                                target="_blank"
                                onClick={handleLinkClicked}
                                className="inline-block bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg text-lg"
                            >
                                {config ? 'Join Secure Channel' : <LoaderComponent small={true} />}
                            </a>
                            <button onClick={handleFinalize} disabled={isButtonDisabled} className="w-full max-w-xs mx-auto bg-green-600 hover:bg-green-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center text-lg">
                                {isButtonDisabled ? `Finalize (${countdown}s)` : 'Finalize Transfer'}
                            </button>
                        </div>
                    );
                case 3:
                     return (
                        <div>
                            <h1 className="text-3xl font-bold text-indigo-400 text-center mb-4">Finalizing Setup...</h1>
                            <ul className="space-y-2 bg-gray-900 p-4 rounded-lg">
                                <StatusItem status={transferStatus.bot.status} message={transferStatus.bot.message} />
                                <StatusItem status={transferStatus.channel.status} message={transferStatus.channel.message} />
                            </ul>
                        </div>
                    );
                default:
                    return null;
            }
        };

        return (
            <div className="min-h-screen bg-gray-900 text-white flex flex-col items-center justify-center p-4 font-sans">
                <div className="w-full max-w-xl bg-gray-800 rounded-xl shadow-2xl p-6 md:p-8">
                    {renderStepContent()}
                    {error && <p className="text-red-400 text-sm text-center mt-4">{error}</p>}
                </div>
            </div>
        );
    };

         // ============================================================================
    // --- MAIN APP COMPONENT (FINAL, CORRECTED VERSION) ---
    // ============================================================================
    function App() {
        const [user, setUser] = React.useState(null);
        const [appState, setAppState] = React.useState('loading'); // loading, auth, setup, transfer, dashboard

        React.useEffect(() => {
            const unsubscribe = auth.onAuthStateChanged(async (currentUser) => {
                if (!currentUser) {
                    setAppState('auth');
                    return;
                }
                setUser(currentUser);
                try {
                    const configDocRef = db.collection(`artifacts/${appIdentifier}/users/${currentUser.uid}/config`).doc('telegram');
                    const docSnap = await configDocRef.get();
                    if (!docSnap.exists) {
                        setAppState('setup');
                    } else {
                        const configData = docSnap.data();
                        if (configData.ownership_transferred) {
                            setAppState('dashboard');
                        } else {
                            setAppState('transfer');
                        }
                    }
                } catch (error) { 
                    console.error("[App] Error checking setup status:", error);
                    setAppState('setup');
                }
            });
            return () => unsubscribe(); 
        }, []); 

        const handleSetupComplete = () => {
            setAppState('transfer');
        };
        
        const handleOwnershipConfirmed = () => {
            setAppState('dashboard');
        };

        if (appState === 'loading') return <FullScreenLoader message="Initializing App..." />;
        
        switch (appState) {
            case 'auth':
                return <AuthView />;
            case 'setup':
                return <SetupView onSetupComplete={handleSetupComplete} />;
            case 'transfer':
                return <OwnershipView onOwnershipConfirmed={handleOwnershipConfirmed} />;
            case 'dashboard':
                return <DashboardView />;
            default:
                return <AuthView />;
        }
    }

    const container = document.getElementById('root');
    const root = ReactDOM.createRoot(container);
    root.render(<App />);

    </script>
</body>
</html>