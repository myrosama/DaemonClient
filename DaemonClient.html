<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DaemonClient</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and Babel for running React in the browser -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Firebase SDKs (using the v8 compat libraries for this browser version) -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>

</head>
<body class="bg-gray-900">
    <div id="root"></div>

    <script type="text/babel">
    // --- Firebase Initialization ---
    // IMPORTANT: Replace with your actual Firebase project configuration!
    const firebaseConfig = {
      apiKey: "AIzaSyAS76sWZA0MTJOgpMHiY5y7y4-FkGISEmI", // Replace with your actual API key
      authDomain: "daemonclient-c0625.firebaseapp.com",
      projectId: "daemonclient-c0625",
      storageBucket: "daemonclient-c0625.appspot.com",
      messagingSenderId: "424457448611",
      appId: "1:424457448611:web:bef99ed8fa6250cd7de316",
      measurementId: "G-QM5BDM6LXC" // Optional: if you use Analytics
    };

    // Initialize Firebase using the global 'firebase' object from the SDK scripts
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    const appIdentifier = 'default-daemon-client'; // Consistent identifier for Firestore paths

    // ============================================================================
    // --- HELPER FUNCTIONS ---
    // ============================================================================
    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    function formatSpeed(bytesPerSecond) {
        if (!bytesPerSecond || bytesPerSecond < 1024) return `...`;
        if (bytesPerSecond < 1024 * 1024) return `${(bytesPerSecond / 1024).toFixed(2)} KB/s`;
        return `${(bytesPerSecond / (1024 * 1024)).toFixed(2)} MB/s`;
    }

    function formatETA(seconds) {
        if (seconds === Infinity || isNaN(seconds) || seconds < 1) return '...';
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = Math.floor(seconds % 60);
        return [h > 0 ? `${h}h` : '', m > 0 ? `${m}m` : '', `${s}s`].filter(Boolean).join(' ');
    }


    // ============================================================================
    // --- TELEGRAM SERVICE LOGIC (WITH UPDATED UPLOAD FUNCTION) ---
    // ============================================================================
    const CHUNK_SIZE = 19 * 1024 * 1024; // 19MB
    const UPLOAD_RETRIES = 10; // << UPDATED from 5 to 10
    const DOWNLOAD_RETRIES = 5;
    const PROACTIVE_DELAY_MS = 1000; // << ADDED: 1 second delay after each successful part
    const CONCURRENT_DOWNLOADS = 5; 

    //vvv UPDATED UPLOAD FUNCTION vvv
    async function uploadFile(file, botToken, channelId, onProgress) {
        console.log(`[UploadService] Starting upload for ${file.name}, Size: ${(file.size / (1024*1024)).toFixed(2)} MB`);
        const totalParts = Math.ceil(file.size / CHUNK_SIZE);
        console.log(`[UploadService] Total parts: ${totalParts}`);
        const uploadedMessageInfo = [];
        let uploadedBytes = 0;
        const startTime = Date.now();

        for (let i = 0; i < totalParts; i++) {
            const partNumber = i + 1;
            const chunk = file.slice(i * CHUNK_SIZE, (i + 1) * CHUNK_SIZE);
            let success = false;
            
            console.log(`[UploadService] Preparing to upload part ${partNumber}/${totalParts}`);

            for (let attempt = 1; attempt <= UPLOAD_RETRIES; attempt++) {
                try {
                    const elapsedTime = (Date.now() - startTime) / 1000 || 1; // Avoid division by zero
                    const speed = uploadedBytes / elapsedTime;
                    const remainingBytes = file.size - uploadedBytes;
                    const eta = (speed > 0) ? remainingBytes / speed : Infinity;

                    onProgress({ 
                        percent: Math.round((uploadedBytes / file.size) * 100), 
                        status: `Uploading part ${partNumber}/${totalParts} (Attempt ${attempt})`,
                        speed: formatSpeed(speed),
                        eta: formatETA(eta)
                    });

                    const formData = new FormData();
                    formData.append('chat_id', channelId);
                    formData.append('document', chunk, `${file.name}.part${String(partNumber).padStart(3, '0')}`);
                    
                    console.log(`[UploadService] Attempt ${attempt}: Sending part ${partNumber}...`);
                    const response = await fetch(`https://api.telegram.org/bot${botToken}/sendDocument`, { method: 'POST', body: formData });
                    const result = await response.json();

                    if (result.ok) {
                        console.log(`[UploadService] Part ${partNumber} uploaded successfully on attempt ${attempt}.`);
                        uploadedMessageInfo.push({ message_id: result.result.message_id, file_id: result.result.document.file_id });
                        uploadedBytes += chunk.size;
                        success = true;
                        break; // Success, break retry loop for this part
                    } else {
                        console.warn(`[UploadService] Part ${partNumber} upload failed on attempt ${attempt}. Status: ${response.status}, Telegram says: ${result.description}`);
                        if (response.status === 429 && result.parameters?.retry_after) {
                            const retryAfter = parseInt(result.parameters.retry_after, 10);
                            console.log(`[UploadService] Rate limit hit (429). Waiting for ${retryAfter} seconds as requested by Telegram...`);
                            onProgress(prev => ({ ...prev, status: `Rate limited. Waiting ${retryAfter}s... (Part ${partNumber})` }));
                            await sleep(retryAfter * 1000 + 500); // Wait and add a small buffer
                        } else {
                            console.log(`[UploadService] Encountered non-429 error. Waiting before retry attempt ${attempt + 1}...`);
                            const waitTime = 2000 * attempt; 
                            await sleep(waitTime);
                        }
                    }
                } catch (error) {
                    console.error(`[UploadService] Network or critical error on part ${partNumber}, attempt ${attempt}:`, error);
                    if (attempt < UPLOAD_RETRIES) {
                        const waitTime = 3000 * attempt; 
                        console.log(`[UploadService] Waiting ${waitTime/1000}s before retry attempt ${attempt + 1} for critical error...`);
                        await sleep(waitTime);
                    } else {
                        throw new Error(`Part ${partNumber} failed after ${UPLOAD_RETRIES} attempts due to critical/network errors: ${error.message}`);
                    }
                }
            } 

            if (!success) {
                throw new Error(`Upload failed for part ${partNumber}. All ${UPLOAD_RETRIES} retries exhausted.`);
            }

            if (partNumber < totalParts) { 
                console.log(`[UploadService] Successfully uploaded part ${partNumber}. Proactively sleeping for ${PROACTIVE_DELAY_MS / 1000}s...`);
                await sleep(PROACTIVE_DELAY_MS);
            }
        } 

        console.log(`[UploadService] Successfully uploaded all ${totalParts} parts of '${file.name}'.`);
        onProgress({ 
            percent: 100, 
            status: `Upload complete!`,
            speed: '', 
            eta: ''
        });
        return uploadedMessageInfo;
    }
    // ^^^ END OF UPDATED UPLOAD FUNCTION ^^^

    async function downloadFile(fileInfo, botToken, onProgress) {
        console.log(`[DownloadService] Starting download for ${fileInfo.fileName}`);
        const { messages, fileName, fileSize } = fileInfo;
        const totalParts = messages.length;
        const partBlobs = new Array(totalParts);
        let downloadedBytes = 0;
        const startTime = Date.now();

        async function downloadPart(partInfo, index) {
            for (let attempt = 1; attempt <= DOWNLOAD_RETRIES; attempt++) {
                try {
                    const fileInfoUrl = `https://api.telegram.org/bot${botToken}/getFile?file_id=${partInfo.file_id}`;
                    const fileInfoRes = await fetch(fileInfoUrl);
                    const fileInfoData = await fileInfoRes.json();
                    if (!fileInfoData.ok) throw new Error(fileInfoData.description || "Failed to get file info from Telegram");
                    
                    const fileUrl = `https://api.telegram.org/file/bot${botToken}/${fileInfoData.result.file_path}`;
                    const fileRes = await fetch(fileUrl);
                    if (!fileRes.ok) throw new Error(`HTTP error downloading part! status: ${fileRes.status}`);
                    
                    const blob = await fileRes.blob();
                    console.log(`[DownloadService] Part ${index + 1} downloaded successfully.`);
                    return blob;
                } catch (error) {
                    console.error(`[DownloadService] Error on part ${index + 1}, attempt ${attempt}:`, error);
                    if (attempt >= DOWNLOAD_RETRIES) throw new Error(`Part ${index + 1} failed after ${DOWNLOAD_RETRIES} attempts: ${error.message}`);
                    await sleep(2000 * attempt);
                }
            }
        }

        const downloadQueue = messages.map((part, index) => async () => {
            const blob = await downloadPart(part, index);
            partBlobs[index] = blob;
            downloadedBytes += blob.size; 
            const elapsedTime = (Date.now() - startTime) / 1000 || 1;
            const speed = downloadedBytes / elapsedTime;
            const remainingBytes = fileSize - downloadedBytes;
            const eta = remainingBytes / speed;
            onProgress({
                percent: Math.round((downloadedBytes / fileSize) * 100),
                status: `Downloaded ${index + 1}/${totalParts}...`,
                speed: formatSpeed(speed),
                eta: formatETA(eta)
            });
        });

        for (const task of downloadQueue) {
            await task();
        }

        onProgress({ percent: 100, status: `Assembling file...`, speed: '', eta: '' });
        const fullBlob = new Blob(partBlobs, { type: fileInfo.fileType || 'application/octet-stream' }); 
        const link = document.createElement('a');
        link.href = URL.createObjectURL(fullBlob);
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
        console.log(`[DownloadService] Download complete for ${fileName}`);
    }

    // ============================================================================
    // --- UI & VIEW COMPONENTS ---
    // ============================================================================
    const LoaderComponent = ({ small }) => <div className={`animate-spin rounded-full border-b-2 border-white ${small ? 'h-6 w-6' : 'h-10 w-10'}`}></div>;
    const LockIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="mr-2 h-10 w-10 text-indigo-400"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>;
    const FullScreenLoader = ({message}) => <div className="flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white"><LoaderComponent /><p className="mt-4 text-lg">{message || "Loading Application..."}</p></div>;

    const ProgressBar = ({ percent, status, speed, eta }) => (
        <div className="w-full mt-4">
            <div className="flex justify-between mb-1 text-xs text-gray-300">
                <span>{status}</span>
                <span>{eta}</span>
            </div>
            <div className="w-full bg-gray-600 rounded-full h-2.5">
                <div className="bg-indigo-500 h-2.5 rounded-full transition-all duration-300 ease-linear" style={{ width: `${percent}%` }}></div>
            </div>
            <div className="text-center text-sm font-semibold text-indigo-300 mt-1">{speed}</div>
        </div>
    );

    const AuthView = () => {
        const [isLoginView, setIsLoginView] = React.useState(true);
        const [email, setEmail] = React.useState('');
        const [password, setPassword] = React.useState('');
        const [error, setError] = React.useState('');
        const [isLoading, setIsLoading] = React.useState(false);

        const handleAuthAction = async (e) => {
            e.preventDefault();
            console.log(`[AuthView] Attempting to ${isLoginView ? 'log in' : 'sign up'} with email: ${email}`);
            if (!email || !password) { setError("Please enter both email and password."); return; }
            setIsLoading(true); setError('');
            try {
                if (isLoginView) {
                    await auth.signInWithEmailAndPassword(email, password);
                    console.log("[AuthView] signInWithEmailAndPassword successful (Firebase auth done). Waiting for App's onAuthStateChanged...");
                } else {
                    await auth.createUserWithEmailAndPassword(email, password);
                    console.log("[AuthView] createUserWithEmailAndPassword successful (Firebase auth done). Waiting for App's onAuthStateChanged...");
                }
            } catch (err) {
                console.error("[AuthView] Firebase Auth action failed:", err);
                setError(err.message.replace('Firebase: ', '')); 
            }
            finally {
                setIsLoading(false);
            }
        };
        return (<div className="min-h-screen bg-gray-900 flex flex-col justify-center items-center p-4 font-sans"><div className="w-full max-w-md"><div className="text-center mb-8"><div className="flex items-center justify-center mb-2"><LockIcon /></div><h1 className="text-4xl font-bold text-white">DaemonClient</h1><p className="text-indigo-300 mt-2">Your Secure Cloud Storage</p></div><div className="bg-gray-800 shadow-2xl rounded-xl p-8"><div className="flex border-b border-gray-700 mb-6"><button onClick={() => { setIsLoginView(true); setError(''); }} className={`w-1/2 py-3 text-lg font-semibold ${isLoginView ? 'text-indigo-400 border-b-2 border-indigo-400' : 'text-gray-500'}`}>Login</button><button onClick={() => { setIsLoginView(false); setError(''); }} className={`w-1/2 py-3 text-lg font-semibold ${!isLoginView ? 'text-indigo-400 border-b-2 border-indigo-400' : 'text-gray-500'}`}>Sign Up</button></div><form onSubmit={handleAuthAction} className="space-y-6"><div><label htmlFor="email-auth" className="block text-sm font-medium text-gray-300 mb-2">Email Address</label><input id="email-auth" type="email" value={email} onChange={(e) => setEmail(e.target.value)} className="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white" required /></div><div><label htmlFor="password-auth" className="block text-sm font-medium text-gray-300 mb-2">Password</label><input id="password-auth" type="password" value={password} onChange={(e) => setPassword(e.target.value)} className="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white" required /></div>{error && <p className="text-red-400 text-sm text-center">{error}</p>}<div><button type="submit" disabled={isLoading} className="w-full flex justify-center py-3 px-4 rounded-lg text-lg font-medium text-white bg-indigo-600 hover:bg-indigo-700 disabled:bg-indigo-800 disabled:opacity-75">{isLoading ? <LoaderComponent small={true} /> : (isLoginView ? 'Log In' : 'Create Account')}</button></div></form></div></div></div>);
    };

    const SetupView = ({ onSetupComplete }) => {
        const [botToken, setBotToken] = React.useState('');
        const [channelId, setChannelId] = React.useState('');
        const [error, setError] = React.useState('');
        const [isLoading, setIsLoading] = React.useState(false);

        const handleSaveSetup = async () => {
            if (!botToken || !channelId) { setError("Bot Token and Channel ID cannot be empty."); return; }
            setIsLoading(true); setError('');
            try {
                const currentUserID = auth.currentUser.uid;
                const firestorePath = `artifacts/${appIdentifier}/users/${currentUserID}/config`;
                console.log(`[SetupView] Attempting to save setup for user: ${currentUserID}, path: ${firestorePath}/telegram`);
                await db.collection(firestorePath).doc('telegram').set({ botToken, channelId, setupTimestamp: firebase.firestore.FieldValue.serverTimestamp() });
                console.log("[SetupView] Setup data successfully saved to Firestore.");
                onSetupComplete();
            } catch (err) {
                console.error("[SetupView] Error saving setup data to Firestore:", err);
                setError(`Failed to save configuration: ${err.message}`);
            }
            finally { setIsLoading(false); }
        };

        const handleLogout = async () => {
            console.log("[SetupView] User initiated logout.");
            try {
                await auth.signOut();
            } catch (error) {
                console.error("[SetupView] Error during sign out:", error);
                setError("Logout failed. Please try again.");
            }
        };

        return (<div className="min-h-screen bg-gray-900 text-white flex flex-col items-center justify-center p-4 font-sans"><div className="w-full max-w-2xl bg-gray-800 rounded-xl shadow-2xl p-8"><div className="text-center mb-6"><h1 className="text-3xl font-bold text-indigo-400">One-Time Setup</h1><p className="text-gray-400 mt-2">Connect your Telegram bot and channel.</p></div><div className="space-y-6"><div><label htmlFor="botToken-setup" className="block text-sm font-medium text-gray-300 mb-2">1. Your Telegram Bot Token</label><p className="text-xs text-gray-500 mb-2">Create a bot with <a href="https://t.me/BotFather" target="_blank" rel="noopener noreferrer" className="text-indigo-400 hover:underline">@BotFather</a> and paste the API token here.</p><input id="botToken-setup" type="password" value={botToken} onChange={(e) => setBotToken(e.target.value)} className="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white focus:ring-2 focus:ring-indigo-500" placeholder="e.g., 123456:ABC-DEF1234..." /></div><div><label htmlFor="channelId-setup" className="block text-sm font-medium text-gray-300 mb-2">2. Your Private Channel ID</label><p className="text-xs text-gray-500 mb-2">Create a private channel, add your bot as an admin, then get the Channel ID (e.g., from @userinfobot, often starts with -100).</p><input id="channelId-setup" type="text" value={channelId} onChange={(e) => setChannelId(e.target.value)} className="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white focus:ring-2 focus:ring-indigo-500" placeholder="e.g., -1001234567890" /></div>{error && <p className="text-red-400 text-sm text-center py-2">{error}</p>}<button onClick={handleSaveSetup} disabled={isLoading} className="w-full bg-indigo-500 hover:bg-indigo-600 disabled:bg-indigo-800 disabled:opacity-75 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center text-lg transition-colors">{isLoading ? <LoaderComponent small={true} /> : 'Save & Continue'}</button></div><div className="text-center mt-6"><button onClick={handleLogout} className="text-sm text-gray-500 hover:text-gray-300">Logout</button></div></div></div>);
    };

    const DashboardView = () => {
        const [config, setConfig] = React.useState(null);
        const [files, setFiles] = React.useState([]);
        const [uploadProgress, setUploadProgress] = React.useState({ active: false, percent: 0, status: '', speed: '', eta: '' });
        const [downloadProgress, setDownloadProgress] = React.useState({ active: false, percent: 0, status: '', speed: '', eta: '' });
        const [feedbackMessage, setFeedbackMessage] = React.useState({ type: '', text: ''});

        const fileInputRef = React.useRef(null);
        const isBusy = uploadProgress.active || downloadProgress.active;

        React.useEffect(() => {
            console.log("[DashboardView] Mounting. Fetching initial data...");
            const fetchInitialData = async () => {
                const currentUserID = auth.currentUser.uid;
                const configDocRef = db.collection(`artifacts/${appIdentifier}/users/${currentUserID}/config`).doc('telegram');
                const filesCollectionRef = db.collection(`artifacts/${appIdentifier}/users/${currentUserID}/files`);

                try {
                    const configSnap = await configDocRef.get();
                    if (configSnap.exists) {
                        console.log("[DashboardView] Config found:", configSnap.data());
                        setConfig(configSnap.data());
                    } else {
                        console.warn("[DashboardView] User config not found in Firestore!");
                    }

                    const filesSnap = await filesCollectionRef.orderBy("uploadedAt", "desc").get();
                    const filesData = filesSnap.docs.map(d => ({ id: d.id, ...d.data() }));
                    console.log(`[DashboardView] Found ${filesData.length} files.`);
                    setFiles(filesData);
                } catch (error) {
                    console.error("[DashboardView] Error fetching initial data:", error);
                    setFeedbackMessage({type: 'error', text: `Error loading data: ${error.message}`});
                }
            };
            if (auth.currentUser) {
                fetchInitialData();
            }
        }, []);

        const clearFeedback = () => setTimeout(() => setFeedbackMessage({type: '', text: ''}), 5000);

        const handleFileUpload = async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            if (!config || !config.botToken || !config.channelId) {
                setFeedbackMessage({type: 'error', text: "Bot configuration is missing. Please re-setup."});
                clearFeedback();
                return;
            }
            console.log(`[DashboardView] File selected for upload: ${file.name}`);
            setUploadProgress({ active: true, percent: 0, status: 'Starting upload...', speed: '', eta: '' });
            setFeedbackMessage({type: '', text: ''});
            try {
                const messageInfo = await uploadFile(file, config.botToken, config.channelId, (p) => setUploadProgress(prev => ({ ...prev, ...p, active: true })));
                const newFileData = {
                    fileName: file.name,
                    fileSize: file.size,
                    fileType: file.type, 
                    uploadedAt: firebase.firestore.Timestamp.now(),
                    messages: messageInfo
                };
                await db.collection(`artifacts/${appIdentifier}/users/${auth.currentUser.uid}/files`).doc(file.name).set(newFileData);
                console.log(`[DashboardView] File metadata saved for ${file.name}`);
                setFiles(prev => [newFileData, ...prev].sort((a, b) => (b.uploadedAt?.toMillis() || 0) - (a.uploadedAt?.toMillis() || 0)));
                setFeedbackMessage({type: 'success', text: `Successfully uploaded and stored '${file.name}'`});
            } catch (err) {
                console.error("[DashboardView] Upload failed:", err);
                setFeedbackMessage({type: 'error', text: `Upload failed: ${err.message}`});
            } finally {
                setUploadProgress({ active: false, percent: 0, status: '', speed: '', eta: '' });
                if(fileInputRef.current) fileInputRef.current.value = ""; 
                clearFeedback();
            }
        };

        const handleFileDownload = async (fileInfo) => {
            if (!config || !config.botToken) {
                setFeedbackMessage({type: 'error', text: "Bot configuration is missing for download."});
                clearFeedback();
                return;
            }
            console.log(`[DashboardView] Initiating download for ${fileInfo.fileName}`);
            setDownloadProgress({ active: true, percent: 0, status: 'Preparing download...', speed: '', eta: '' });
            setFeedbackMessage({type: '', text: ''});
            try {
                await downloadFile(fileInfo, config.botToken, (p) => setDownloadProgress(prev => ({ ...prev, ...p, active: true })));
                setFeedbackMessage({type: 'success', text: `Successfully downloaded '${fileInfo.fileName}'`});
            } catch (err) {
                console.error("[DashboardView] Download failed:", err);
                setFeedbackMessage({type: 'error', text: `Download failed: ${err.message}`});
            } finally {
                setDownloadProgress({ active: false, percent: 0, status: '', speed: '', eta: '' });
                clearFeedback();
            }
        };

        const handleLogout = async () => {
            console.log("[DashboardView] User initiated logout.");
            try {
                await auth.signOut();
            } catch (error) {
                console.error("[DashboardView] Error during sign out:", error);
                setFeedbackMessage({type: 'error', text: "Logout failed."});
                clearFeedback();
            }
        };

        if (!config && !feedbackMessage.text) { 
             return <FullScreenLoader message="Loading Dashboard..." />;
        }

        return (<div className="min-h-screen bg-gray-900 text-white flex items-center justify-center p-4 font-sans"><div className="w-full max-w-3xl bg-gray-800 rounded-xl shadow-2xl p-6"><div className="flex justify-between items-center mb-4"><h1 className="text-3xl font-bold text-indigo-400">DaemonClient</h1><button onClick={handleLogout} className="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg text-sm">Logout</button></div>
        <div className="bg-gray-700 p-4 rounded-lg mb-6"><h2 className="text-xl font-semibold mb-2">Upload File</h2><input type="file" ref={fileInputRef} onChange={handleFileUpload} className="hidden" disabled={isBusy} /><button onClick={() => fileInputRef.current.click()} disabled={isBusy || !config} className="w-full bg-indigo-500 hover:bg-indigo-600 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded-lg mt-2">Choose File to Upload (/upload)</button></div>
        {uploadProgress.active && <ProgressBar percent={uploadProgress.percent} status={uploadProgress.status} speed={uploadProgress.speed} eta={uploadProgress.eta} />}

        <div className="bg-gray-700 p-4 rounded-lg mt-4"><h2 className="text-xl font-semibold mb-2">Your Files</h2><div className="mt-4 space-y-2 max-h-60 overflow-y-auto pr-2">{files.length > 0 ? files.map(file => (<div key={file.id || file.fileName} className="flex justify-between items-center bg-gray-800 p-3 rounded-lg hover:bg-gray-750 transition-colors"><div><p className="font-semibold text-white truncate w-60" title={file.fileName}>{file.fileName}</p><p className="text-xs text-gray-400">{(file.fileSize / 1024 / 1024).toFixed(2)} MB {file.uploadedAt?.toDate().toLocaleDateString()}</p></div><button onClick={() => handleFileDownload(file)} disabled={isBusy} className="bg-green-600 hover:bg-green-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-1 px-3 rounded-md text-sm">Download</button></div>)) : <p className="text-center text-gray-400 py-4">No files uploaded yet.</p>}</div></div>
        {downloadProgress.active && <ProgressBar percent={downloadProgress.percent} status={downloadProgress.status} speed={downloadProgress.speed} eta={downloadProgress.eta} />}

        {feedbackMessage.text && <div className={`mt-4 p-3 rounded-lg text-sm text-center ${feedbackMessage.type === 'error' ? 'bg-red-900 text-red-200' : 'bg-green-900 text-green-200'}`}>{feedbackMessage.text}</div>}
        {!uploadProgress.active && !downloadProgress.active && !feedbackMessage.text && <div className="h-12 mt-4"></div> }
    </div></div>);
    };

    // ============================================================================
    // --- THE MAIN APP (The Conductor) ---
    // ============================================================================
    function App() {
        const [user, setUser] = React.useState(null);
        const [isSetupComplete, setIsSetupComplete] = React.useState(false);
        const [isLoading, setIsLoading] = React.useState(true); 

        React.useEffect(() => {
            console.log("[App] Setting up Firebase auth state listener...");
            const unsubscribe = auth.onAuthStateChanged(async (currentUser) => {
                console.log(`[App] Auth state changed. Current user: ${currentUser ? currentUser.uid : 'No user'}`);
                setIsLoading(true);
                if (currentUser) {
                    setUser(currentUser); 
                    console.log(`[App] User ${currentUser.uid} detected. Checking setup status...`);
                    try {
                        const userConfigPath = `artifacts/${appIdentifier}/users/${currentUser.uid}/config`;
                        const userDocRef = db.collection(userConfigPath).doc('telegram');
                        console.log(`[App] Checking Firestore path: ${userConfigPath}/telegram`);
                        const docSnap = await userDocRef.get();

                        if (docSnap.exists && docSnap.data().botToken) {
                            console.log("[App] Setup IS complete. Bot token found.", docSnap.data());
                            setIsSetupComplete(true);
                        } else {
                            console.log("[App] Setup is NOT complete. Bot token missing or doc doesn't exist.");
                            setIsSetupComplete(false);
                        }
                    } catch (error) {
                        console.error("[App] Error checking user setup status in Firestore:", error);
                        setIsSetupComplete(false);
                    }
                } else {
                    console.log("[App] No user is signed in.");
                    setUser(null);
                    setIsSetupComplete(false);
                }
                console.log("[App] Finished processing auth state. Setting isLoading to false.");
                setIsLoading(false);
            });

            return () => {
                console.log("[App] Cleaning up Firebase auth state listener.");
                unsubscribe();
            };
        }, []); 

        console.log(`[App] Rendering with state: isLoading=${isLoading}, user=${user ? user.uid : 'null'}, isSetupComplete=${isSetupComplete}`);

        if (isLoading) {
            console.log("[App] Render: FullScreenLoader");
            return <FullScreenLoader />;
        }

        if (!user) {
            console.log("[App] Render: AuthView (no user)");
            return <AuthView />;
        }

        if (isSetupComplete) {
            console.log("[App] Render: DashboardView (user logged in, setup complete)");
            return <DashboardView />;
        } else {
            console.log("[App] Render: SetupView (user logged in, setup NOT complete)");
            return <SetupView onSetupComplete={() => {
                console.log("[App] onSetupComplete called from SetupView. Updating isSetupComplete to true.");
                setIsSetupComplete(true);
            }} />;
        }
    }

    const container = document.getElementById('root');
    const root = ReactDOM.createRoot(container);
    root.render(<App />);

    </script>
</body>
</html>