<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DaemonClient</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and Babel for running React in the browser -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Firebase SDKs (using the v8 compat libraries for this browser version) -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>

</head>
<body class="bg-gray-900">
    <div id="root"></div>

    <script type="text/babel">
    // --- Firebase Initialization ---
    // THIS BLOCK IS NOW UPDATED WITH THE VALUES YOU PROVIDED FROM YOUR CONSOLE
    const firebaseConfig = {
      apiKey: "AIzaSyAS76sWZA0MTJOgpMHiY5y7y4-FkGISEmI",
      authDomain: "daemonclient-c0625.firebaseapp.com",
      databaseURL: "https://daemonclient-c0625-default-rtdb.firebaseio.com",
      projectId: "daemonclient-c0625",
      storageBucket: "daemonclient-c0625.firebasestorage.app",
      messagingSenderId: "424457448611",
      appId: "1:424457448611:web:bef99ed8fa6250cd7de316",
      measurementId: "G-QM5BDM6LXC"
    };

    // Initialize Firebase using the global 'firebase' object from the SDK scripts
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    const appIdentifier = 'default-daemon-client'; 

    // ============================================================================
    // --- HELPER FUNCTIONS & CONSTANTS (TELEGRAM LOGIC) ---
    // ============================================================================
    const CHUNK_SIZE = 19 * 1024 * 1024; // 19MB
    const UPLOAD_RETRIES = 10;
    const DOWNLOAD_RETRIES = 5;
    const PROACTIVE_DELAY_MS = 1000; // Delay after each successful upload part
    
    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    function formatSpeed(bytesPerSecond) {
        if (!bytesPerSecond || bytesPerSecond < 1024 || isNaN(bytesPerSecond)) return `...`;
        if (bytesPerSecond < 1024 * 1024) return `${(bytesPerSecond / 1024).toFixed(2)} KB/s`;
        return `${(bytesPerSecond / (1024 * 1024)).toFixed(2)} MB/s`;
    }

    function formatETA(seconds) {
        if (seconds === Infinity || isNaN(seconds) || seconds < 1) return '...';
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = Math.floor(seconds % 60);
        return [h > 0 ? `${h}h` : '', m > 0 ? `${m}m` : '', s > 0 ? `${s}s` : (h===0 && m===0 ? '0s' : '')].filter(Boolean).join(' ') || '...';
    }

    async function uploadFile(file, botToken, channelId, onProgress) {
        console.log(`[HTML/uploadFile] Starting upload for ${file.name}, Size: ${(file.size / (1024*1024)).toFixed(2)} MB`);
        const totalParts = Math.ceil(file.size / CHUNK_SIZE);
        const uploadedMessageInfo = [];
        let uploadedBytes = 0;
        const startTime = Date.now();

        for (let i = 0; i < totalParts; i++) {
            const partNumber = i + 1;
            const chunk = file.slice(i * CHUNK_SIZE, (i + 1) * CHUNK_SIZE);
            let success = false;
            
            for (let attempt = 1; attempt <= UPLOAD_RETRIES; attempt++) {
                try {
                    const elapsedTime = (Date.now() - startTime) / 1000 || 1;
                    const speed = uploadedBytes / elapsedTime;
                    const remainingBytes = file.size - uploadedBytes;
                    const eta = (speed > 0 && remainingBytes > 0) ? remainingBytes / speed : Infinity;

                    onProgress({ 
                        percent: Math.round((uploadedBytes / file.size) * 100), 
                        status: `Uploading part ${partNumber}/${totalParts} (Attempt ${attempt})`,
                        speed: formatSpeed(speed),
                        eta: formatETA(eta)
                    });

                    const formData = new FormData();
                    formData.append('chat_id', channelId);
                    formData.append('document', chunk, `${file.name}.part${String(partNumber).padStart(3, '0')}`);
                    
                    const response = await fetch(`https://api.telegram.org/bot${botToken}/sendDocument`, { method: 'POST', body: formData });
                    const result = await response.json();

                    if (result.ok) {
                        uploadedMessageInfo.push({ message_id: result.result.message_id, file_id: result.result.document.file_id });
                        uploadedBytes += chunk.size;
                        success = true;
                        break; 
                    } else {
                        console.warn(`[HTML/uploadFile] Part ${partNumber} failed (Attempt ${attempt}): ${result.description}`);
                        if (response.status === 429 && result.parameters?.retry_after) {
                            const retryAfter = parseInt(result.parameters.retry_after, 10);
                            onProgress(prev => ({ ...prev, status: `Rate limited. Waiting ${retryAfter}s... (Part ${partNumber})` }));
                            await sleep(retryAfter * 1000 + 500);
                        } else {
                            await sleep(2000 * attempt); 
                        }
                    }
                } catch (error) {
                    console.error(`[HTML/uploadFile] Network/critical error on part ${partNumber} (Attempt ${attempt}):`, error);
                    if (attempt < UPLOAD_RETRIES) {
                        await sleep(3000 * attempt);
                    } else {
                        throw new Error(`Part ${partNumber} failed after ${UPLOAD_RETRIES} attempts due to critical errors: ${error.message}`);
                    }
                }
            } 
            if (!success) {
                throw new Error(`Upload failed for part ${partNumber}. All ${UPLOAD_RETRIES} retries exhausted.`);
            }
            if (partNumber < totalParts) { 
                await sleep(PROACTIVE_DELAY_MS);
            }
        } 
        onProgress({ percent: 100, status: `Upload complete!`, speed: '', eta: ''});
        return uploadedMessageInfo;
    }

    async function downloadFile(fileInfo, botToken, onProgress) {
        console.log(`[HTML/downloadFile] Starting download for ${fileInfo.fileName}`);
        const { messages, fileName, fileSize, fileType } = fileInfo;
        const totalParts = messages.length;
        const partBlobs = new Array(totalParts); 
        let downloadedBytes = 0;
        const startTime = Date.now();

        async function downloadPartWithRetry(partData, index) {
            for (let attempt = 1; attempt <= DOWNLOAD_RETRIES; attempt++) {
                try {
                    const fileInfoUrl = `https://api.telegram.org/bot${botToken}/getFile?file_id=${partData.file_id}`;
                    const fileInfoRes = await fetch(fileInfoUrl);
                    const fileInfoData = await fileInfoRes.json();
                    if (!fileInfoData.ok) throw new Error(`TG getFile error: ${fileInfoData.description || "Unknown"}`);
                    
                    const fileUrl = `https://api.telegram.org/file/bot${botToken}/${fileInfoData.result.file_path}`;
                    const fileRes = await fetch(fileUrl);
                    if (!fileRes.ok) throw new Error(`HTTP error ${fileRes.status} downloading part`);
                    
                    return await fileRes.blob();
                } catch (error) {
                    console.error(`[HTML/downloadFile] Error on part ${index + 1} (Attempt ${attempt}):`, error);
                    if (attempt >= DOWNLOAD_RETRIES) throw error; 
                    await sleep(2000 * attempt); 
                }
            }
        }
        
        for (let i = 0; i < totalParts; i++) {
            const partData = messages[i];
            const blob = await downloadPartWithRetry(partData, i);
            partBlobs[i] = blob;
            downloadedBytes += blob.size;

            const elapsedTime = (Date.now() - startTime) / 1000 || 1;
            const speed = downloadedBytes / elapsedTime;
            const remainingBytes = fileSize - downloadedBytes; 
            const eta = (remainingBytes > 0 && speed > 0) ? remainingBytes / speed : 0;
            
            onProgress({
                percent: Math.round((downloadedBytes / fileSize) * 100),
                status: `Downloaded part ${i + 1}/${totalParts}...`,
                speed: formatSpeed(speed),
                eta: formatETA(eta)
            });
            if (i < totalParts - 1) { 
                await sleep(500); 
            }
        }

        onProgress({ percent: 100, status: `Assembling file...`, speed: '', eta: '' });
        const fullBlob = new Blob(partBlobs, { type: fileType || 'application/octet-stream' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(fullBlob);
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
        console.log(`[HTML/downloadFile] Download complete for ${fileName}`);
    }

    // ============================================================================
    // --- UI & VIEW COMPONENTS ---
    // ============================================================================
    const LoaderComponent = ({ small }) => <div className={`animate-spin rounded-full border-b-2 border-white ${small ? 'h-6 w-6' : 'h-10 w-10'}`}></div>;
    const LockIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="mr-2 h-10 w-10 text-indigo-400"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>;
    const FullScreenLoader = ({message}) => <div className="flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white"><LoaderComponent /><p className="mt-4 text-lg">{message || "Loading Application..."}</p></div>;

    const ProgressBar = ({ percent, status, speed, eta }) => (
        <div className="w-full mt-4">
            <div className="flex justify-between mb-1 text-xs text-gray-300">
                <span>{status}</span>
                <span>{eta || '...'}</span>
            </div>
            <div className="w-full bg-gray-600 rounded-full h-2.5">
                <div className="bg-indigo-500 h-2.5 rounded-full transition-all duration-300 ease-linear" style={{ width: `${percent}%` }}></div>
            </div>
            <div className="text-center text-sm font-semibold text-indigo-300 mt-1">{speed || '...'}</div>
        </div>
    );

        // --- THIS REPLACES YOUR EXISTING AuthView FUNCTION ---
        const AuthView = () => {
        const [isLoginView, setIsLoginView] = React.useState(true);
        const [email, setEmail] = React.useState('');
        const [password, setPassword] = React.useState('');
        const [error, setError] = React.useState('');
        const [isLoading, setIsLoading] = React.useState(false);

        const handleAuthAction = async (e) => {
            e.preventDefault();
            if (!email || !password) { setError("Please enter email and password."); return; }
            setIsLoading(true); 
            setError(''); // Clear previous errors

            try {
                if (isLoginView) {
                    await auth.signInWithEmailAndPassword(email, password);
                    // onAuthStateChanged in App will handle the view change
                } else {
                    await auth.createUserWithEmailAndPassword(email, password);
                    // onAuthStateChanged in App will handle the view change
                }
            } catch (err) {
                // --- The updated error handling logic is here ---
                console.error("[AuthView] Firebase Auth action failed. Code:", err.code);

                switch (err.code) {
                    // Cases for LOGIN
                    case 'auth/user-not-found':
                        setError("No account found with this email address. Please sign up.");
                        break;
                    case 'auth/wrong-password':
                        setError("Incorrect password. Please try again.");
                        break;
                    case 'auth/invalid-credential': // This is a modern catch-all for both errors above
                        setError("Invalid credentials. Please check your email and password.");
                        break;
                    case 'auth/too-many-requests':
                        setError("Too many login attempts. Please try again later.");
                        break;

                    // Cases for SIGN UP
                    case 'auth/email-already-in-use':
                        setError("An account with this email already exists. Please log in instead.");
                        break;
                    case 'auth/weak-password':
                        setError("Password is too weak. It should be at least 6 characters long.");
                        break;
                    case 'auth/invalid-email':
                        setError("The email address format is not valid.");
                        break;

                    // Default fallback
                    default:
                        setError("An unexpected error occurred. Please try again.");
                        break;
                }
            }
            finally {
                setIsLoading(false);
            }
        };

        return (
            <div className="min-h-screen bg-gray-900 flex flex-col justify-center items-center p-4 font-sans">
                <div className="w-full max-w-md">
                    <div className="text-center mb-8">
                        <div className="flex items-center justify-center mb-2">
                            <LockIcon />
                        </div>
                        <h1 className="text-4xl font-bold text-white">DaemonClient</h1>
                        <p className="text-indigo-300 mt-2">Your Secure Cloud Storage</p>
                    </div>
                    <div className="bg-gray-800 shadow-2xl rounded-xl p-8">
                        <div className="flex border-b border-gray-700 mb-6">
                            <button onClick={() => { setIsLoginView(true); setError(''); }} className={`w-1/2 py-3 text-lg font-semibold ${isLoginView ? 'text-indigo-400 border-b-2 border-indigo-400' : 'text-gray-500'}`}>
                                Login
                            </button>
                            <button onClick={() => { setIsLoginView(false); setError(''); }} className={`w-1/2 py-3 text-lg font-semibold ${!isLoginView ? 'text-indigo-400 border-b-2 border-indigo-400' : 'text-gray-500'}`}>
                                Sign Up
                            </button>
                        </div>
                        <form onSubmit={handleAuthAction} className="space-y-6">
                            <div>
                                <label htmlFor="email-auth" className="block text-sm font-medium text-gray-300 mb-2">Email Address</label>
                                <input id="email-auth" type="email" value={email} onChange={(e) => setEmail(e.target.value)} className="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white" required />
                            </div>
                            <div>
                                <label htmlFor="password-auth" className="block text-sm font-medium text-gray-300 mb-2">Password</label>
                                <input id="password-auth" type="password" value={password} onChange={(e) => setPassword(e.target.value)} className="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white" required />
                            </div>
                            {error && <p className="text-red-400 text-sm text-center">{error}</p>}
                            <div>
                                <button type="submit" disabled={isLoading} className="w-full flex justify-center py-3 px-4 rounded-lg text-lg font-medium text-white bg-indigo-600 hover:bg-indigo-700 disabled:bg-indigo-800 disabled:opacity-75">
                                    {isLoading ? <LoaderComponent small={true} /> : (isLoginView ? 'Log In' : 'Create Account')}
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            </div>
        );
    };
    // --- END OF REPLACEMENT FOR AuthView ---

    const SetupView = ({ onSetupComplete }) => {
        const [botToken, setBotToken] = React.useState('');
        const [channelId, setChannelId] = React.useState('');
        const [error, setError] = React.useState('');
        const [isLoading, setIsLoading] = React.useState(false);

        const handleSaveSetup = async () => {
            if (!botToken.trim() || !channelId.trim()) { setError("Bot Token and Channel ID are required."); return; }
            setIsLoading(true); setError('');
            try {
                const currentUserID = auth.currentUser.uid;
                const configDocRef = db.collection(`artifacts/${appIdentifier}/users/${currentUserID}/config`).doc('telegram');
                await configDocRef.set({ 
                    botToken: botToken.trim(), 
                    channelId: channelId.trim(), 
                    setupTimestamp: firebase.firestore.FieldValue.serverTimestamp() 
                });
                onSetupComplete();
            } catch (err) { setError(`Save failed: ${err.message}`); }
            finally { setIsLoading(false); }
        };
        const handleLogout = async () => { try { await auth.signOut(); } catch (err) { setError("Logout failed."); }};
        return (<div className="min-h-screen bg-gray-900 text-white flex flex-col items-center justify-center p-4 font-sans"><div className="w-full max-w-2xl bg-gray-800 rounded-xl shadow-2xl p-8"><div className="text-center mb-6"><h1 className="text-3xl font-bold text-indigo-400">One-Time Setup</h1><p className="text-gray-400 mt-2">Connect your Telegram bot and channel.</p></div><div className="space-y-6"><div><label htmlFor="botToken-setup" className="block text-sm font-medium text-gray-300 mb-2">1. Telegram Bot Token</label><p className="text-xs text-gray-500 mb-2">From <a href="https://t.me/BotFather" target="_blank" rel="noopener noreferrer" className="text-indigo-400 hover:underline">@BotFather</a>.</p><input id="botToken-setup" type="password" value={botToken} onChange={(e) => setBotToken(e.target.value)} className="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white focus:ring-2 focus:ring-indigo-500" placeholder="e.g., 123456:ABC-DEF1234..." /></div><div><label htmlFor="channelId-setup" className="block text-sm font-medium text-gray-300 mb-2">2. Private Channel ID</label><p className="text-xs text-gray-500 mb-2">Add bot as admin. Get ID (e.g., from @userinfobot, often starts -100).</p><input id="channelId-setup" type="text" value={channelId} onChange={(e) => setChannelId(e.target.value)} className="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white focus:ring-2 focus:ring-indigo-500" placeholder="e.g., -1001234567890" /></div>{error && <p className="text-red-400 text-sm text-center py-2">{error}</p>}<button onClick={handleSaveSetup} disabled={isLoading} className="w-full bg-indigo-500 hover:bg-indigo-600 disabled:bg-indigo-800 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center text-lg transition-colors">{isLoading ? <LoaderComponent small={true} /> : 'Save & Continue'}</button></div><div className="text-center mt-6"><button onClick={handleLogout} className="text-sm text-gray-500 hover:text-gray-300">Logout</button></div></div></div>);
    };

    // --- THIS IS THE REVISED DashboardView FUNCTION ---
    const DashboardView = () => {
        const [config, setConfig] = React.useState(null); 
        const [isLoadingConfig, setIsLoadingConfig] = React.useState(true); 
        const [configError, setConfigError] = React.useState(''); 

        const [files, setFiles] = React.useState([]);
        const [isLoadingFiles, setIsLoadingFiles] = React.useState(true); 

        const [uploadProgress, setUploadProgress] = React.useState({ active: false, percent: 0, status: '', speed: '', eta: '' });
        const [downloadProgress, setDownloadProgress] = React.useState({ active: false, percent: 0, status: '', speed: '', eta: '' });
        const [feedbackMessage, setFeedbackMessage] = React.useState({ type: '', text: ''});

        const fileInputRef = React.useRef(null);
        const isUploading = uploadProgress.active;
        const isDownloading = downloadProgress.active;
        const isBusy = isUploading || isDownloading;

        React.useEffect(() => {
            const currentAuthUser = auth.currentUser;
            console.log("[DashboardView] useEffect triggered. User:", currentAuthUser ? currentAuthUser.uid : "None");

            if (currentAuthUser) {
                setIsLoadingConfig(true); setIsLoadingFiles(true);
                setConfigError(''); setConfig(null); setFiles([]); 

                const fetchData = async () => {
                    const currentUserID = currentAuthUser.uid;
                    try { // Fetch Config
                        const configDocRef = db.collection(`artifacts/${appIdentifier}/users/${currentUserID}/config`).doc('telegram');
                        const configSnap = await configDocRef.get();
                        if (configSnap.exists() && configSnap.data().botToken) {
                            setConfig(configSnap.data());
                        } else {
                            setConfigError("Configuration not found. Please re-setup."); setConfig(null); 
                        }
                    } catch (error) { setConfigError(`Error loading config: ${error.message}`); setConfig(null);
                    } finally { setIsLoadingConfig(false); }
                    
                    try { // Fetch Files
                        const filesCollectionRef = db.collection(`artifacts/${appIdentifier}/users/${currentUserID}/files`);
                        const filesQuery = filesCollectionRef.orderBy("uploadedAt", "desc");
                        const filesSnap = await filesQuery.get();
                        const filesData = filesSnap.docs.map(d => ({ id: d.id, ...d.data() }));
                        setFiles(filesData);
                    } catch (error) { console.error("[DashboardView] Error fetching files:", error);
                    } finally { setIsLoadingFiles(false); }
                };
                fetchData();
            } else { setIsLoadingConfig(false); setIsLoadingFiles(false); setConfig(null); setFiles([]); }
        }, []); 

        const clearFeedback = (delay = 4000) => setTimeout(() => setFeedbackMessage({type: '', text: ''}), delay);

        const handleFileUpload = async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            if (!config || !config.botToken || !config.channelId) {
                setFeedbackMessage({type: 'error', text: "Bot configuration not loaded. Wait or re-setup."}); clearFeedback(); return;
            }
            setUploadProgress({ active: true, percent: 0, status: 'Starting upload...', speed: '', eta: '' });
            setFeedbackMessage({type: '', text: ''});
            try {
                const messageInfo = await uploadFile(file, config.botToken, config.channelId, (p) => setUploadProgress(prev => ({ ...prev, ...p, active: true })));
                const newFileData = {fileName: file.name, fileSize: file.size, fileType: file.type, uploadedAt: firebase.firestore.Timestamp.now(), messages: messageInfo};
                await db.collection(`artifacts/${appIdentifier}/users/${auth.currentUser.uid}/files`).doc(file.name).set(newFileData);
                setFiles(prev => [newFileData, ...prev].sort((a,b)=>(b.uploadedAt?.toMillis()||0)-(a.uploadedAt?.toMillis()||0) ));
                setFeedbackMessage({type: 'success', text: `Uploaded '${file.name}'`});
            } catch (err) { setFeedbackMessage({type: 'error', text: `Upload failed: ${err.message}`});
            } finally { setUploadProgress({ active: false, percent: 0, status: '', speed: '', eta: '' }); if(fileInputRef.current) fileInputRef.current.value = ""; clearFeedback(); }
        };

        const handleFileDownload = async (fileInfo) => {
            if (!config || !config.botToken) { setFeedbackMessage({type: 'error', text: "Bot configuration not loaded."}); clearFeedback(); return; }
            if (!fileInfo || !fileInfo.messages || fileInfo.messages.length === 0) { setFeedbackMessage({type: 'error', text: "File info incomplete."}); clearFeedback(); return; }
            setDownloadProgress({ active: true, percent: 0, status: 'Preparing download...', speed: '', eta: '' });
            setFeedbackMessage({type: '', text: ''});
            try {
                await downloadFile(fileInfo, config.botToken, (p) => setDownloadProgress(prev => ({ ...prev, ...p, active: true })));
                setFeedbackMessage({type: 'success', text: `Downloaded '${fileInfo.fileName}'`});
            } catch (err) { setFeedbackMessage({type: 'error', text: `Download failed: ${err.message}`});
            } finally { setDownloadProgress({ active: false, percent: 0, status: '', speed: '', eta: '' }); clearFeedback(); }
        };
        const handleLogout = async () => { try { await auth.signOut(); } catch (err) { setFeedbackMessage({type: 'error', text: "Logout failed."}); clearFeedback(); }};

        if (isLoadingConfig || isLoadingFiles) return <FullScreenLoader message={isLoadingConfig ? "Loading Configuration..." : "Loading Files..."} />;
        if (configError) return (<div className="min-h-screen bg-gray-900 text-white flex items-center justify-center p-4 font-sans"><div className="w-full max-w-3xl bg-gray-800 rounded-xl shadow-2xl p-6"><div className="flex justify-between items-center mb-4"><h1 className="text-3xl font-bold text-indigo-400">DaemonClient</h1><button onClick={handleLogout} className="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg text-sm">Logout</button></div><div className="p-4 bg-red-700 text-red-100 rounded-lg"><h2 className="text-xl font-semibold mb-2">Configuration Error</h2><p>{configError}</p><p className="mt-2">Try logging out and in, or re-setup.</p></div></div></div>);
        
        return (<div className="min-h-screen bg-gray-900 text-white flex items-center justify-center p-4 font-sans"><div className="w-full max-w-3xl bg-gray-800 rounded-xl shadow-2xl p-6"><div className="flex justify-between items-center mb-4"><h1 className="text-3xl font-bold text-indigo-400">DaemonClient</h1><button onClick={handleLogout} className="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg text-sm">Logout</button></div><div className="bg-gray-700 p-4 rounded-lg mb-6"><h2 className="text-xl font-semibold mb-2">Upload File</h2><input type="file" ref={fileInputRef} onChange={handleFileUpload} className="hidden" disabled={isBusy || !config} /><button onClick={() => fileInputRef.current.click()} disabled={isBusy || !config} className="w-full bg-indigo-500 hover:bg-indigo-600 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded-lg mt-2">Choose File to Upload (/upload)</button></div>{isUploading && <ProgressBar percent={uploadProgress.percent} status={uploadProgress.status} speed={uploadProgress.speed} eta={uploadProgress.eta} />}{/* Files List */}<div className="bg-gray-700 p-4 rounded-lg mt-4"><h2 className="text-xl font-semibold mb-2">Your Files</h2><div className="mt-4 space-y-2 max-h-60 overflow-y-auto pr-2">{files.length > 0 ? files.map(file => (<div key={file.id || file.fileName} className="flex justify-between items-center bg-gray-800 p-3 rounded-lg hover:bg-gray-750 transition-colors"><div><p className="font-semibold text-white truncate w-60" title={file.fileName}>{file.fileName}</p><p className="text-xs text-gray-400">{(file.fileSize / 1024 / 1024).toFixed(2)} MB {file.uploadedAt?.toDate ? ` - ${file.uploadedAt.toDate().toLocaleDateString()}` : ''}</p></div><button onClick={() => handleFileDownload(file)} disabled={isBusy || !config} className="bg-green-600 hover:bg-green-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-1 px-3 rounded-md text-sm">Download</button></div>)) : (<p className="text-center text-gray-400 py-4">No files uploaded yet.</p>)}</div></div>{isDownloading && <ProgressBar percent={downloadProgress.percent} status={downloadProgress.status} speed={downloadProgress.speed} eta={downloadProgress.eta} />}{feedbackMessage.text && <div className={`mt-4 p-3 rounded-lg text-sm text-center ${feedbackMessage.type === 'error' ? 'bg-red-900 text-red-200' : 'bg-green-900 text-green-200'}`}>{feedbackMessage.text}</div>}{!isUploading && !isDownloading && !feedbackMessage.text && <div className="h-12 mt-4"></div> }</div></div>);
    };
    // --- END OF REVISED DashboardView ---

    // ============================================================================
    // --- THE MAIN APP (The Conductor) ---
    // ============================================================================
    function App() {
        const [user, setUser] = React.useState(null);
        const [isSetupComplete, setIsSetupComplete] = React.useState(false);
        const [isLoading, setIsLoading] = React.useState(true); 

        React.useEffect(() => {
            const unsubscribe = auth.onAuthStateChanged(async (currentUser) => {
                console.log("[App] Auth state changed. User:", currentUser ? currentUser.uid : "None");
                setIsLoading(true); 
                if (currentUser) {
                    setUser(currentUser); 
                    try {
                        const configDocRef = db.collection(`artifacts/${appIdentifier}/users/${currentUser.uid}/config`).doc('telegram');
                        const docSnap = await configDocRef.get();
                        if (docSnap.exists() && docSnap.data().botToken) {
                            setIsSetupComplete(true);
                        } else {
                            setIsSetupComplete(false);
                        }
                    } catch (error) { 
                        console.error("[App] Error checking setup status:", error);
                        setIsSetupComplete(false); 
                    }
                } else { 
                    setUser(null); 
                    setIsSetupComplete(false);
                }
                setIsLoading(false); 
            });
            return () => unsubscribe(); 
        }, []); 

        if (isLoading) return <FullScreenLoader message="Initializing App..." />;
        if (!user) return <AuthView />;
        if (isSetupComplete) return <DashboardView />;
        return <SetupView onSetupComplete={() => setIsSetupComplete(true)} />;
    }

    const container = document.getElementById('root');
    const root = ReactDOM.createRoot(container);
    root.render(<App />);

    </script>
</body>
</html>